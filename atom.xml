<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Luckey</title>
  
  <subtitle>LoveZDF博客</subtitle>
  <link href="http://www.luckyzmj.cn/atom.xml" rel="self"/>
  
  <link href="http://www.luckyzmj.cn/"/>
  <updated>2021-09-20T13:31:12.852Z</updated>
  <id>http://www.luckyzmj.cn/</id>
  
  <author>
    <name>Luckey</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++内存分区</title>
    <link href="http://www.luckyzmj.cn/posts/14b8e558.html"/>
    <id>http://www.luckyzmj.cn/posts/14b8e558.html</id>
    <published>2021-09-20T10:03:51.528Z</published>
    <updated>2021-09-20T13:31:12.852Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="windows下C-的内存分区"><a href="#windows下C-的内存分区" class="headerlink" title="windows下C++的内存分区"></a>windows下C++的内存分区</h1><h3 id="五大分区"><a href="#五大分区" class="headerlink" title="五大分区"></a>五大分区</h3><p>在windows中五大分区地址由高至低依次是：</p><ul><li>堆区：由用户主动申请</li><li>栈区：由高地址向低地址生长，编译器自动分配。存放局部变量、局部常量</li><li>全局区：存放全局变量，全局静态变量、局部静态变量。</li><li>常量区：存放<strong>文字常量</strong>、全局常量、全局静态常量、局部静态常量。</li><li>代码区：存放程序代码。</li></ul><p>其中常量区和代码区都是只可读不可写。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> a1 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">//全局常量</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> a2 <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>  <span class="token comment">//全局静态常量</span><span class="token keyword">static</span> <span class="token keyword">int</span> a3 <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>  <span class="token comment">//全局静态变量</span><span class="token keyword">int</span> a4 <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>       <span class="token comment">//全局变量</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s <span class="token operator">=</span> <span class="token string">"32"</span><span class="token punctuation">;</span> <span class="token comment">//文字常量</span>    <span class="token keyword">int</span> a5 <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span> <span class="token comment">//局部变量</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> a6 <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token comment">//局部常量</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> a7 <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>   <span class="token comment">//局部静态常量</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> a8 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>   <span class="token comment">//局部静态变量</span>    <span class="token keyword">int</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> p3 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>a3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> p4 <span class="token operator">=</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a4<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> p5 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>a5<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> p6 <span class="token operator">=</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a6<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> p7 <span class="token operator">=</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a7<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> p8 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>a8<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> p9 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//堆中申请的局部变量</span>    <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> p10 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//堆中申请的局部常量</span>    <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>测试结果</strong><br><a href="https://imgtu.com/i/4Gq3Xd"><img src="https://z3.ax1x.com/2021/09/20/4Gq3Xd.png"></a></p><p>由以上测试结果可得，各中类型数据所在的位置分布</p><table><thead><tr><th>类型</th><th>地址</th><th>所在分区</th></tr></thead><tbody><tr><td>堆局部常量</td><td>0x011775a8</td><td>堆区</td></tr><tr><td>堆局部变量</td><td>0x01170588</td><td>堆区</td></tr><tr><td>局部变量</td><td>0x00faf6fc</td><td>栈区</td></tr><tr><td>局部常量</td><td>0x00faf6f0</td><td>栈区</td></tr><tr><td>局部静态变量</td><td>0x00eaa008</td><td>全局区</td></tr><tr><td>静态全局变量</td><td>0x00eaa004</td><td>全局区</td></tr><tr><td>全局变量</td><td>0x00eaa000</td><td>全局区</td></tr><tr><td>文字常量</td><td>0x00ea7b40</td><td>常量区</td></tr><tr><td>局部静态常量</td><td>0x00ea7b38</td><td>常量区</td></tr><tr><td>全局静态常量</td><td>0x00ea7b34</td><td>常量区</td></tr><tr><td>全局常量</td><td>0x00ea7b30</td><td>常量区</td></tr></tbody></table><p>这样我们就得到了不同类型数据的内存分布位置。</p><p>并且我们还可以知道 由于a5先于a6定义，而a5的地址高于a6可以知道，<strong>栈内存是从高地址向地址生长的</strong>。<br>我们可以进一步测试：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a1<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a3 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a4 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a3<span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a4 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://imgtu.com/i/4GqNAP"><img src="https://z3.ax1x.com/2021/09/20/4GqNAP.png"></a><br>可以明显知道，变量a1到a4地址逐个降低，进一步说明了<strong>栈内存是从高地址向低地址生长</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="博客篇" scheme="http://www.luckyzmj.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"/>
    
    
    <category term="C++" scheme="http://www.luckyzmj.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>型别推导</title>
    <link href="http://www.luckyzmj.cn/posts/89c1cd20.html"/>
    <id>http://www.luckyzmj.cn/posts/89c1cd20.html</id>
    <published>2021-09-20T10:00:19.195Z</published>
    <updated>2021-09-20T10:04:11.233Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="型别推导"><a href="#型别推导" class="headerlink" title="型别推导"></a>型别推导</h1><h3 id="模板中的型别推导规则"><a href="#模板中的型别推导规则" class="headerlink" title="模板中的型别推导规则"></a>模板中的型别推导规则</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>Paramtype param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>以上是模板和调用的一般形式。<br>现在我们需要考虑在模板型别推导过程中出现的一般情况。</p><ul><li><p>Paramtype 是个指针或者引用，但不是万能引用。<br>在这种情况下，型别推导将会按照如下过程运作：</p><ul><li>如果expr具有引用，则<strong>将引用忽略</strong>。（在形参类型不是万能引用的情况下，实参类型是否具有引用对于形参的类型并无影响）</li><li>将忽略引用后的expr与Paramtype 进行模式匹配，推导出T的类型。</li></ul></li><li><p>Paramtype是个万能引用。</p><ul><li> 如果expr是个左值，T和Paramtype都会被推导为左值引用。</li><li> 如果expr是个右值，则应用第一种情况的规则。</li></ul></li><li><p>Paramtype既不是指针也不是引用。<br>这也就意味着在这种情况下采用传值的方式。由于在传值的情况下，形参都是实参的副本，这样在进行型别推导时就需要忽略实参的引用以及const和volatile。</p></li><li><p>在模板型别推导过程中，数组或函数型别的实参会退化成对应的指针，除非他们被用来初始化引用。</p></li></ul><h3 id="auto-型别推导"><a href="#auto-型别推导" class="headerlink" title="auto 型别推导"></a>auto 型别推导</h3><p>auto将等号右边的值看做实参，进行型别推导。其推导规则与模板型别推导基本一致。<br>auto型别推导与模板型别推导的唯一不同就是当采用<strong>列表初始化</strong>的方式初始化变量时，该变量的类型会被推导为initializer_list&lt; T&gt;。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> a<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//a的类型被推导为initializer_list&lt;int&gt;</span><span class="token keyword">auto</span> a1<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1.0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//由于大括号中的值类型不一致，因此无法推导出initializer_list&lt;T&gt; 中的T</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="decltype-型别推导"><a href="#decltype-型别推导" class="headerlink" title="decltype 型别推导"></a>decltype 型别推导</h3><ul><li>在绝大多数情况下，decltype会得出变量或表达式的型别而不做任何修改。</li><li>对于型别为T的表达式，除非该表达式仅有一个名字，decltype总是得出型别T&amp;。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="博客篇" scheme="http://www.luckyzmj.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"/>
    
    
    <category term="C++" scheme="http://www.luckyzmj.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>解析vector在msvc中的增长方式</title>
    <link href="http://www.luckyzmj.cn/posts/8544f5f8.html"/>
    <id>http://www.luckyzmj.cn/posts/8544f5f8.html</id>
    <published>2021-08-14T16:00:00.000Z</published>
    <updated>2021-09-20T10:06:22.613Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="解析vector在msvc中的增长方式"><a href="#解析vector在msvc中的增长方式" class="headerlink" title="解析vector在msvc中的增长方式"></a>解析vector在msvc中的增长方式</h1><p><a href="https://imgtu.com/i/48WeMT"><img src="https://z3.ax1x.com/2021/09/20/48WeMT.jpg"></a></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>首先，我们在vs2019中对于vector的增长方式进行测试。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"    "</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>结果</strong><br><a href="https://imgtu.com/i/4GoZjI"><img src="https://z3.ax1x.com/2021/09/20/4GoZjI.png"></a></p><p>由图中结果可以看出，每次重新分配空间，<strong>vector的容量增长了原容量的一半。</strong></p><h3 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a>分析源码</h3><p>首先，调用push_back函数。<br><a href="https://imgtu.com/i/4Go83j"><img src="https://z3.ax1x.com/2021/09/20/4Go83j.png"></a><br>在<strong>push_back</strong>函数内部调用<strong>emplace_back</strong>。<br><a href="https://imgtu.com/i/4GogDx"><img src="https://z3.ax1x.com/2021/09/20/4GogDx.png"></a><br>而在emplace_back内部，当容量不足时，会调用 <strong>_Emplace_reallocate</strong>函数，来重新分配内存空间。<br><a href="https://imgtu.com/i/4GoND0"><img src="https://z3.ax1x.com/2021/09/20/4GoND0.png"></a><br>在该函数内部，会更新size与capacity的值。通过函数 <strong>_Calculate_growth</strong>来计算vector新的容量值。<br><a href="https://imgtu.com/i/4Goh5D"><img src="https://z3.ax1x.com/2021/09/20/4Goh5D.png"></a></p><ul><li>如果旧容量与旧容量的1/2的和超过了所能分配的最大内存，则返回该最大内存的值。</li><li>否则，将新内存更新为旧容量与旧容量的1/2的和。即<strong>容量增长了原容量的一半。</strong></li><li>如果增长后的容量值仍不足，则将容量更新为_Newsize。即<strong>如果一次性在vector中添加了超过原容量的1/2的数据，那么新容量的值就是添加数据所占的容量与原容量的和，即不预留额外空间。</strong></li></ul><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>从以上测试结果，以及对于源码的分析可以看出，vector每次增长原容量的一半。那么这么做的原因是什么呢？<br>C++ STL 中 vector 内存用尽后, 为什么每次是 2 倍的增长, 而不是 3 倍或其他值? - Milo Yip的回答 - 知乎<br><a href="https://www.zhihu.com/question/36538542/answer/67994276">https://www.zhihu.com/question/36538542/answer/67994276</a></p><p>如果采用2倍增长的策略，由于每次新分配的内存必定大于之前所分配内存的总和，这样之前缓存就永远无法被利用。而如果采用1.5倍增长的话，理论上就可以利用之前分配过的缓存（<strong>缓存友好</strong>）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="博客篇" scheme="http://www.luckyzmj.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"/>
    
    
    <category term="C++" scheme="http://www.luckyzmj.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>解析迭代器</title>
    <link href="http://www.luckyzmj.cn/posts/b67a3ab3.html"/>
    <id>http://www.luckyzmj.cn/posts/b67a3ab3.html</id>
    <published>2020-03-14T16:00:00.000Z</published>
    <updated>2021-09-20T10:04:11.235Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h3 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h3><p>向容器中添加元素：</p><ul><li>如果容器是vector或string，并且重新分配内存空间，那么所有迭代器、指针、引用都会失效。如果没有重新分配内存，那么在添加元素位置之后的迭代器、指针、引用都会失效。</li><li>如果容器是deque，那么插入到除首尾之外的任何位置都会导致迭代器、指针、引用失效。插入到首尾位置，迭代器会失效。</li><li>如果容器是list和forward_list，指向容器的迭代器、指针和引用仍有效。</li></ul><p>从容器中删除元素：</p><ul><li>如果容器是list和forward_list，指向容器其他位置的迭代器、引用、指针仍然有效。</li><li>对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器失效，但其他迭代器、指针和引用不会失效。如果是删除首元素，这些也不会受影响。</li><li>对于vector和string，指向被删除元素之前元素的迭代器、引用指针仍有效。</li></ul><h3 id="迭代器失效原因"><a href="#迭代器失效原因" class="headerlink" title="迭代器失效原因"></a>迭代器失效原因</h3><p>迭代器之所以会失效是由于迭代器原本指向的对象的地址发生改变，导致迭代器所存储的地址中的对象将不再正确。</p><ul><li><p>在<strong>vector</strong>和<strong>string</strong>中，如果<strong>重新分配内存</strong>，那么其中所有元素的地址都会发生改变。那么我们在这之前所获得的迭代器指向的对象则发生改变，如果我们仍然继续使用这些迭代器，将会导致严重的错误。如果没有重新分配内存，那么在该位置之后元素需要全部后移，那么指向这些元素的迭代器当然也会失效。</p></li><li><p>在<strong>deque</strong>中，由于deque的底层实现方式比较特殊，因此其迭代器可能失效的情况也与vector和string不太一样。<br>如果在deque的首部或者尾部插入元素：</p><ul><li>首先，由于deque的特殊设计，deque的内部元素不会发生移动，那么这些元素的指针和引用便不会失效。但是由于在首部或尾部添加元素可能会导致deque增加新的<strong>chunk</strong>，这就会导致其迭代器失效。</li><li>而如果要在deque内部插入元素的话，那么其他元素都可能会发生移动，因此这些元素的迭代器、指针和引用都会失效。</li></ul></li><li><p>在<strong>list</strong>中，由于list是环形链表，因此无论是执行插入还是删除操作都不会改变其元素的地址，因此list中的迭代器、指针和引用不会失效。</p></li></ul><h3 id="msvc能够检测迭代器是否失效"><a href="#msvc能够检测迭代器是否失效" class="headerlink" title="msvc能够检测迭代器是否失效"></a>msvc能够检测迭代器是否失效</h3><p>msvc在debug模式下可以检测迭代器是否失效。<br>检测方法：<br>c++标准库是如何实现迭代器失效的？ - rayhunter的回答 - 知乎<br><a href="https://www.zhihu.com/question/460078504/answer/1893604802">https://www.zhihu.com/question/460078504/answer/1893604802</a><br>通过一个隐式的迭代器链表来检测迭代器是否失效。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="博客篇" scheme="http://www.luckyzmj.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"/>
    
    
    <category term="C++" scheme="http://www.luckyzmj.cn/tags/C/"/>
    
  </entry>
  
</feed>
