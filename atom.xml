<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lovezdf</title>
  
  <subtitle>LoveZDF的博客</subtitle>
  <link href="http://www.luckyzmj.cn/atom.xml" rel="self"/>
  
  <link href="http://www.luckyzmj.cn/"/>
  <updated>2021-09-22T09:40:52.803Z</updated>
  <id>http://www.luckyzmj.cn/</id>
  
  <author>
    <name>LoveZDF</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>排序算法</title>
    <link href="http://www.luckyzmj.cn/posts/735e5788.html"/>
    <id>http://www.luckyzmj.cn/posts/735e5788.html</id>
    <published>2021-09-21T10:28:33.745Z</published>
    <updated>2021-09-22T09:40:52.803Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p><strong>排序算法的稳定性</strong>：如果两个相等的元素，在排序前与排序后的相对次序保持一致，那么该排序算法就是稳定的。否则，该排序算法就是不稳定的。</p><h3 id="O-n-2-排序算法"><a href="#O-n-2-排序算法" class="headerlink" title="O((n^2)) 排序算法"></a>O((n^2)) 排序算法</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>冒泡排序在每一轮遍历中，进行两两比较，如果前者比后者大就交换二者。这样在每一轮遍历后，未排序元素中的最大值就会被交换到序列末尾，与已排序序列构成新的排序序列。</p><p><strong>代码实现</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> data<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>时间复杂度</strong>： O((n^2))<br><strong>稳定性</strong>：冒泡排序是<strong>稳定的</strong>。<br><strong>算法优化</strong><br>如果剩余序列是有序的话，也就没有必要在继续下面的遍历。如果在一轮遍历过后没有发生交换，这就说明剩余序列已经有序，这样我们就可以根据是否发生交换，来决定是否终止循环。<br><strong>优化代码</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">bool</span> if_swap <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> data<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">swap</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> if_swap <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>if_swap<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在代码优化后，当序列完全有序时，就只需要一次遍历，时间复杂度可以达到 O((n^2))。</p><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>每轮在剩余元素中寻找最小的元素，将其交换到已排序序列的尾部。<br>一共需要(n-1)轮。<br><strong>代码实现</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">choose_sort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> data<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> min_l <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> data<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> data<span class="token punctuation">[</span>min_l<span class="token punctuation">]</span><span class="token punctuation">)</span> min_l <span class="token operator">=</span> j<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>min_l<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>时间复杂度</strong>： O((n^2))<br><strong>稳定性</strong>： 选择排序算法是<strong>不稳定的</strong>。<br>例： {3，3，1} 在排序后 为{1，3，3}。在这个排序过程中，两个3的位置发生了改变，因此说明选择排序算法是不稳定的。</p><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>每轮将未排序序列的第一个元素插入到已排序序列中合适的位置。<br><strong>代码实现</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">insert_sort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> data<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> data<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>时间复杂度</strong> O((n^2))<br>对于插入排序来说，<strong>由于内层循环在找到当前元素的合适位置后就可以终止循环，因此，当原序列越有序，插入排序时间复杂度就越小</strong>。<br>在极端情况下，如果原序列是<strong>排好序的</strong>，那么该插入排序的时间复杂度就变为O((n))。</p><p><strong>算法优化</strong>：<br>减少拷贝次数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">insert_sort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> data<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> value <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> j<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token operator">&amp;&amp;</span>value<span class="token operator">&lt;</span>data<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>               data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>data<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                     <span class="token punctuation">}</span>            data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>稳定性</strong>：插入排序算法是<strong>稳定的</strong>。</p><h3 id="O-n-log-n-排序算法"><a href="#O-n-log-n-排序算法" class="headerlink" title="O((n\log n)) 排序算法"></a>O((n\log n)) 排序算法</h3><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>将序列划分为小序列，将排好序的小序列<strong>归并</strong>，就得到了排好序的最终序列。</p><p><strong>时间复杂度</strong>：共需要划分(logn)层，每此归并需要O((n))归并。 O((nlogn))<br><strong>稳定性</strong>：归并排序是<strong>稳定的</strong>。<br><strong>自顶而下的归并排序</strong><br><strong>代码实现</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> data<span class="token punctuation">,</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&gt;=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> li <span class="token operator">=</span> l<span class="token punctuation">,</span> ri <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">result</span><span class="token punctuation">(</span>r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">merge</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">merge</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>li <span class="token operator">&lt;</span> mid<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">||</span> ri <span class="token operator">&lt;</span> r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ri<span class="token operator">&gt;=</span>r<span class="token operator">+</span><span class="token number">1</span><span class="token operator">||</span><span class="token punctuation">(</span>li<span class="token operator">&lt;</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>data<span class="token punctuation">[</span>li<span class="token punctuation">]</span><span class="token operator">&lt;=</span>data<span class="token punctuation">[</span>ri<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>li<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token operator">++</span>i<span class="token punctuation">;</span>            <span class="token operator">++</span>li<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>ri<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token operator">++</span>i<span class="token punctuation">;</span>            <span class="token operator">++</span>ri<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        data<span class="token punctuation">[</span>l <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">merge</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> data<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>算法优化</strong><br>当我们归并两个数组时，如果前面的个数组的最大值小于后一个数组的最小值时，便不用对两个数组进行操作，因为当前已经有序了。</p><p><strong>自底而上的归并排序</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> data<span class="token punctuation">,</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> mid<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> li <span class="token operator">=</span> l<span class="token punctuation">,</span> ri <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">result</span><span class="token punctuation">(</span>r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> data<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>li <span class="token operator">&lt;</span> mid<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">||</span> ri <span class="token operator">&lt;</span> r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ri<span class="token operator">&gt;=</span>r<span class="token operator">+</span><span class="token number">1</span><span class="token operator">||</span><span class="token punctuation">(</span>li<span class="token operator">&lt;</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>data<span class="token punctuation">[</span>li<span class="token punctuation">]</span><span class="token operator">&lt;=</span>data<span class="token punctuation">[</span>ri<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>li<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token operator">++</span>i<span class="token punctuation">;</span>            <span class="token operator">++</span>li<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>ri<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token operator">++</span>i<span class="token punctuation">;</span>            <span class="token operator">++</span>ri<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        data<span class="token punctuation">[</span>l <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> data<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">+=</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">+</span>i <span class="token operator">&lt;</span> data<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j <span class="token operator">+=</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">merge</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">+</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>data<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>将当前数组根据一个基准划分为两部分，一部分比该基准小，另一部分大于该基准。之后，在分别对两个子数组执行快速排序。</p><p><strong>时间复杂度</strong>：O((nlogn))<br><strong>稳定性</strong>：快速排序是<strong>不稳定的</strong>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">_quicksort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> data<span class="token punctuation">,</span><span class="token keyword">int</span> begin<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>begin <span class="token operator">&gt;=</span> end<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> begin<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> begin <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> data<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>s <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">++</span>s<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">swap</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_quicksort</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> s<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_quicksort</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> s<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">_quicksort</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> data<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>算法优化</strong>：<br>对于一个有序的序列，快速排序的排序时间复杂度会退化到O((n^2))。<br>快速排序对于有序度高的序列，排序速度很慢。<br>可以随机选择基准元素，而不是总是选择当前序列的第一个元素作为基准元素。</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h3 id="拓展算法"><a href="#拓展算法" class="headerlink" title="拓展算法"></a>拓展算法</h3><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="http://www.luckyzmj.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://www.luckyzmj.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构 面经</title>
    <link href="http://www.luckyzmj.cn/posts/4ccac3ce.html"/>
    <id>http://www.luckyzmj.cn/posts/4ccac3ce.html</id>
    <published>2021-09-21T10:21:15.751Z</published>
    <updated>2021-09-21T10:41:23.354Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h3><h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><h5 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h5><h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><h5 id="排序算法对比"><a href="#排序算法对比" class="headerlink" title="排序算法对比"></a>排序算法对比</h5><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面经" scheme="http://www.luckyzmj.cn/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="算法" scheme="http://www.luckyzmj.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="面经" scheme="http://www.luckyzmj.cn/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>C++ 面经</title>
    <link href="http://www.luckyzmj.cn/posts/d426d8b5.html"/>
    <id>http://www.luckyzmj.cn/posts/d426d8b5.html</id>
    <published>2021-09-20T14:42:08.009Z</published>
    <updated>2021-09-21T06:31:24.632Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="C-面经"><a href="#C-面经" class="headerlink" title="C++ 面经"></a>C++ 面经</h1><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><h4 id="引用、指针"><a href="#引用、指针" class="headerlink" title="引用、指针"></a>引用、指针</h4><h4 id="define"><a href="#define" class="headerlink" title="define"></a>define</h4><ul><li><strong>define与const的区别</strong></li><li><strong>define与inline的区别</strong></li></ul><h4 id="static作用"><a href="#static作用" class="headerlink" title="static作用"></a>static作用</h4><ul><li>1.<strong>修饰局部变量</strong>。将对象声明为静态对象。静态对象的生命期一直持续到程序结束。</li><li>2.<strong>修饰成员变量</strong>。将类中的成员变量声明为静态成员变量。这样该类的所有对象共同拥有该成员变量。</li><li>3.<strong>修饰成员函数</strong>。将类中的成员函数声明为静态成员函数。这样不用通过该类的对象也可以直接调用该函数。</li><li>4.<strong>修饰全局变量</strong>。该变量只在本编译单元可见。</li><li>5.<strong>修饰函数</strong>。该函数只在本编译单元可见。</li></ul><h4 id="C-、面向对象特性"><a href="#C-、面向对象特性" class="headerlink" title="C++、面向对象特性"></a>C++、面向对象特性</h4><ul><li>多态</li><li>继承</li><li>封装</li></ul><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><h5 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h5><p>动态数组</p><ul><li>常用方法：<ul><li>push_back：在尾部添加一个元素</li><li>emplace_back:传入参数，在尾部直接构造一个新元素</li><li>clear</li><li>assign：将vector的内容替换为参数内容。</li><li>reserve：分配至少能容纳n个元素的空间。如果要分配的内存空间小于当前大小，则什么也不做。</li></ul></li><li>数组增长方式：<br>二倍增长，1/4缩小。<br>在msvc中（vs2019）的具体实现是，<strong>每次增加原容量的一半</strong>，即1.5倍增长。具体内容见另一篇文章。</li></ul><h5 id="string"><a href="#string" class="headerlink" title="string"></a>string</h5><p>字符串<br>字符串的常用方法大部分与vector相似。</p><ul><li>构造函数： <ul><li>string s(cp,n); s是cp指向的数组的前n个字符的拷贝。</li><li>string s(s2,pos2); s是string s2从下标pos2开始的字符的拷贝。</li><li>string s(s2,pos2,len)；s是string s2从下标pos2开始len个字符的拷贝。</li></ul></li><li><strong>substr</strong> ：返回string的子串  s.substr(6,11);</li><li><strong>shrink_to_fit</strong> ：通过释放不使用的内存，减少内存的使用。</li><li><strong>find</strong> :在字符串中寻找子串。</li><li><strong>npos</strong>：静态成员。size_type类型 特殊值，size_type类型可以表示的最大值。返回string下标的函数将 <strong>npos</strong>作为错误指示器。</li><li><strong>append</strong> :在字符串末尾进行插入操作。</li><li><strong>replace</strong>： s.replace(range,args);<strong>删除</strong>s中范围range内的字符，<strong>替换</strong>为args中指定的字符。</li></ul><h5 id="map、set-multimap、multimap-unordered-map"><a href="#map、set-multimap、multimap-unordered-map" class="headerlink" title="map、set multimap、multimap unordered_map"></a>map、set multimap、multimap unordered_map</h5><ul><li>底层实现： map、set：红黑树  unordered_map： 哈希表</li></ul><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>连接容器与算法<br>有的容器的迭代器只是对普通指针的简单封装。如vector。<br>有的容器的迭代器则需要复杂的实现。如deque。<br>迭代器种类：</p><ul><li>input_iterator</li><li>output_iterator</li><li>forward_iterator</li><li>bidireational_iterator</li><li>random_access_iterator</li><li>迭代器失效问题：</li></ul><h4 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h4><h5 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h5><p>队列： 先入先出</p><h5 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h5><p>栈：先入后出</p><h5 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h5><p>优先队列：最大堆、最小堆  </p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p><strong>模板一定要放在头文件吗？</strong><br><strong>模板的声明与定义必须放在同一文件中</strong>。因为如果不这样做的话，在模板实例化时编译器就无法找到模板的定义。<br>如果模板的声明与定义没有放在同一文件中，那么在实例化时编译器无法找到模板的定义也就没有实例化模板定义，这样在链接时就会出现链接错误。<br>但是模板并不一定要放在头文件中。</p><h4 id="型别推导"><a href="#型别推导" class="headerlink" title="型别推导"></a>型别推导</h4><p>当我们使用函数模板时并不需要显示声明模板参数的值，这就需要编译器对参数类型进行<strong>型别推导</strong>，来确定模板参数的值。<br>具体的型别推导规则见另一篇文章。</p><h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><p>当我们只是声明一个模板类时，编译器什么也不会做，并不会对该模板进行实例化，不会生成类定义。<br>只有当我们显示或隐式实例化该模板后，编译器才会为实例生成代码，生成类定义，执行<strong>实例化</strong>。</p><ul><li><strong>显式实例化</strong>：<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">extern</span> <span class="token keyword">template</span> <span class="token keyword">class</span> <span class="token class-name">test</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">//实例化声明</span><span class="token keyword">template</span> <span class="token keyword">class</span> <span class="token class-name">test</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">//实例化定义</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p><strong>对于每个实例化声明，在程序中某个位置必须有其显式的实例化定义。</strong><br>显示实例化会实例化模板的所有成员。</p><ul><li><strong>隐式实例化</strong>：<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">test<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>对于模板类的成员函数，只有我们<strong>使用到的成员函数</strong>才会被生成出来，编译器只会实例化这些使用到的成员函数，并不会实例化所有成员函数。</li></ul><h4 id="重载与模板"><a href="#重载与模板" class="headerlink" title="重载与模板"></a>重载与模板</h4><p><strong>函数模板与函数重载的区别</strong></p><p>函数模板可以被另一个模板或一个普通非模板函数重载。与往常一样，名字相同的函数必须具有不同数量或类型的参数。<br>如果涉及函数模板，则函数匹配规则会在以下几方面受到影响：</p><ul><li>对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例。</li><li>候选的函数模板总是可行的，因为模板实参推断会排除任何不可行的模板。</li><li>如果恰有一个函数提供比其他函数都更好的函数匹配，则选择此函数。<br>但是如果有多个函数提供同样好的匹配，则<ul><li>如果同样好的函数中<strong>只有一个是非模板函数</strong>，则选择此函数。</li><li>如果同样好的函数中没有非模板函数，而有多个函数模板，且其中一个函数模板比其他函数模板更特例化，则选择此模板。</li><li>否则，此调用有歧义。</li></ul></li></ul><h4 id="特化"><a href="#特化" class="headerlink" title="特化"></a>特化</h4><p>特化是由于对于某种特殊的类型需要修改模板的定义，对该类型进行特别处理。<br>函数模板特化就是为<strong>所有模板参数指定实参</strong>。<br><strong>函数模板特例化的本质是实例化一个模板</strong>，而非重载它，因此特例化不影响函数匹配。<br>类模板特例化不用为所有模板参数指定实参。<br>而当有多个模板参数时，就需要考虑是否需要对所有模板参数都特殊化处理。当只对其中部分模板参数进行特殊化处理时，就是 <strong>偏特化</strong>，对所有模板参数都需要特殊化处理时，就是 <strong>全特化</strong>。</p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="C-内存分区"><a href="#C-内存分区" class="headerlink" title="C++ 内存分区"></a>C++ 内存分区</h4><ul><li>代码区：存储代码</li><li>数据区(常量区)：存储文字常量 常量字符串、全局常量</li><li>全局区（静态区）：存储全局变量、静态数据</li><li>栈区: 局部变量、局部常量</li><li>堆区:用户申请内存</li></ul><h4 id="new、delete"><a href="#new、delete" class="headerlink" title="new、delete:"></a>new、delete:</h4><p>new 和delete都是操作符。<br>auto p=new T(args):先分配内存空间（operator new），在根据参数调用对象的构造函数。<br>delete p:先调用对象的析构函数，再释放内存空间（operator delete）。</p><h4 id="new-、delete"><a href="#new-、delete" class="headerlink" title="new[]、delete []:"></a>new[]、delete []:</h4><p>auto p=new T[3];  分配空间， 调用3次T的默认构造函数。<br>delete[] p;  调用三次T的析构函数，再释放空间。<br>由此可见，new[]与 delete[]必须对应使用，如果使用 new[]而调用delete释放空间，那么就只会调用一次T的析构函数，这样就会造成内存泄漏。<br>当我们使用new[] 分配内存时，会在分配的内存之前另外分配一个<strong>cookie</strong>空间来记录长度，这样在调用delete[]时，就可以读取该<strong>cookie</strong>来知道需要调用几次析构函数。</p><h4 id="operator-new、operator-delete"><a href="#operator-new、operator-delete" class="headerlink" title="operator new、operator delete"></a>operator new、operator delete</h4><p>operator new与operator delete 是函数。<br>::operator new默认调用malloc。<br>::operator delete默认调用free。<br>我们可以对operator new、operator delete进行重载。</p><h4 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h4><p>由于我们无法直接调用构造函数，因此如果我们希望在某个内存上直接调用构造函数构造对象，就需要placement new的帮助。<br>placement new是operator new的重载函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>```  <span class="token operator">*</span><span class="token operator">*</span>使用方法<span class="token operator">*</span><span class="token operator">*</span><span class="token keyword">new</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token function">T</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>  在p指针指向的内存上调用T的构造函数。### 对象模型##### 对象大小静态成员变量并不存储在对象内部。因此在计算对象大小时，不需要考虑静态成员变量的大小。<span class="token number">32</span>位： <span class="token operator">-</span> <span class="token keyword">int</span> <span class="token number">4</span>个字节 <span class="token operator">-</span> 指针 <span class="token number">4</span>个字节（在<span class="token number">64</span>位下是<span class="token number">8</span>个字节） <span class="token operator">-</span> <span class="token keyword">char</span> <span class="token number">1</span>个字节 <span class="token operator">-</span> <span class="token keyword">float</span> <span class="token number">4</span>个字节 <span class="token operator">-</span> <span class="token keyword">double</span> <span class="token number">8</span>个字节要求得对象的大小还需要考虑<span class="token operator">*</span><span class="token operator">*</span>字节对齐<span class="token operator">*</span><span class="token operator">*</span>。在msvc中字节对齐要满足两个要求： <span class="token operator">-</span> 每个非静态成员变量的偏移量应该是自己类型大小的整数倍。 <span class="token operator">-</span> 最终对象大小的值应该是各个非静态成员变量的最大值的倍数```cpp<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>来设置字节对齐值，上面就将字节对齐值设为1。<br><strong>字节对齐的原因</strong>：</p><ul><li>可以提升CPU访问数据的效率：如果字节不对齐的话，可能要通过两次读取操作才能完成对于数据的读取，但是如果内存对齐的话，只要一次就可以了。</li></ul><h5 id="拷贝构造函数、拷贝赋值函数、析构函数"><a href="#拷贝构造函数、拷贝赋值函数、析构函数" class="headerlink" title="拷贝构造函数、拷贝赋值函数、析构函数"></a>拷贝构造函数、拷贝赋值函数、析构函数</h5><p>在拷贝赋值函数（即operator=）中，注意对于<strong>自我赋值</strong>的处理。</p><ul><li><p><strong>析构函数为什么要采用虚函数？</strong><br>因为如果通过父类指针调用析构函数，并且该指针指向的是子类对象，并且析构函数不是虚函数的话，就只会析构该子类对象的父类部分，这就会导致错误。</p></li><li><p><strong>为什么构造函数不能是虚函数？</strong><br>（1）<strong>将构造函数定义为虚函数是无意义的</strong>。<br>所谓利用<strong>虚机制</strong>实现运行时多态，<strong>实际上是通过指针实际所指对象的不同调用不同的函数。</strong><br>但是如果对象尚未被创建出来，我们就无法获取实际对象的类型信息，也就无法实现动态绑定。<br>（2）如果我们希望通过动态绑定的方式调用构造函数，那么就必须要通过<strong>虚指针</strong>来实现，但是由于此时对象并为被创建，也就没有虚指针，这样也就无法通过动态绑定来实现对于虚构造函数的调用。因此构造函数无法是虚函数。<br>（3）构造函数是在创建对象时被自动调用的，因此即便我们将构造函数是虚函数，我们也无法通过动态绑定的方式来调用。</p></li><li><p><strong>为什么不能让析构函数抛出异常?</strong><br>因为在处理异常时，会析构已经构造的对象，如果此时析构函数抛出异常，那么就会同时出现两个异常，C++无法同时处理两个异常，会导致程序直接退出或是未知行为。</p></li><li><p><strong>编译器为我们编写那些函数</strong>？<br>如果我们没有声明构造函数、析构函数、拷贝构造函数或是拷贝赋值函数，编译器会为我们声明它们。并且 当我们调用这些函数时，它们才会被编译器创建出来。</p></li></ul><p><strong>注意</strong>：编译器生成的析构函数是<strong>非虚的</strong>，除非该类的父类的析构函数是虚函数。</p><ul><li><strong>为什么不能在构造函数或是析构函数中调用虚函数？</strong><br>因为在构造函数或是析构函数中，对于虚函数的调用并不会下降到子类的虚函数中。因为在这些过程中，子类的构造尚未完成或者是子类的析构已经开始，在这两种情况下，该对象都会被视为基类对象。</li></ul><h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><ul><li><strong>编译时多态</strong>:函数重载<br>函数重载实现原理：</li></ul><p><strong>名字重整</strong>：编译器将每个唯一的方法和参数列表组合编码成一个对于链接器来说唯一的名字（mangling）。<br>这样C++就可以实现对于重载函数的区分。这也就是为什么只有返回值类型不同的函数无法被区分，因为其返回值类型不会被体现在函数对应的符号中。链接器也就无法区分它们。<br><strong>重整规则</strong>：一个被重整的类名字是由名字中字符的整数数量，后面跟原始名字组成的。<br>则</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token class-name">Foo</span><span class="token operator">::</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//被重整为 bar__3Fooil</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>运行时多态</strong>：虚函数</li></ul><p><strong>实现方式</strong>：动态绑定 当通过一个基类的指针或者引用调用某个虚函数时，会根据该指针或引用真正指向的对象类型来调用对应的函数。<br>动态绑定的实现过程：当通过对象的指针或引用调用虚函数时，先通过<strong>虚指针</strong>找到<strong>虚函数表</strong>，再查表找到对应的虚函数的函数地址，在执行函数调用。<br>在这个过程中，由于对象的指针或者引用所真正指向的对象的不同，会导致找到的虚指针的不同，也就实现了<strong>运行期多态</strong>。<br>在mvsc中，<strong>虚指针</strong>位于对象的头部位置。</p><p><strong>重载和重写的区别</strong><br><strong>重载</strong>是在定义多个具有相同函数名而具有不同参数列表的函数，在编译器实现多态。<br><strong>重写</strong>是在子类中重写父类的虚函数，二者除了内部实现以外完全相同，通过这样实现运行时多态。</p><h5 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h5><p>内联函数就是将函数体直接放置在调用它的位置，这样就减少了函数调用的开销。<br>inline只是对编译器的一个申请，并不一定会执行。<br><strong>inline与 #define的区别</strong><br>二者都是将函数体替换对于函数的调用。但是编写宏要注意很多细节，较为麻烦。而inline则只需要像编写正常函数一样编写，只需要在函数前面加上inline即可。而且内联函数是个真正的函数，内联函数遵守作用域和访问规则。</p><h3 id="C-11、14新语法"><a href="#C-11、14新语法" class="headerlink" title="C++ 11、14新语法"></a>C++ 11、14新语法</h3><h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><ul><li><p><strong>资源管理类</strong></p></li><li><p><strong>引用计数</strong>：同一块内存的所有智能指针共用一个引用计数。每个智能指针内部包含一个指向一个内存，该内存存放智能指针指向的内存对应的引用计数。</p></li><li><p><strong>智能指针实现</strong></p></li><li><p><strong>shared_ptr、unique_ptr和weak_ptr区别</strong><br>shared_ptr:允许多个指针指向同一个对象 </p><ul><li>make_shared函数：在堆中分配一个对象，返回该对象的shared_ptr。<br>unique_ptr：独占指向的对象。</li></ul><p>由于shared_ptr可能会出现循环引用的情况，因此需要利用 weak_ptr来解决这种情况。<br>weak_ptr：是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。由于weak_ptr所指向的对象可能不存在， 因此我们不能直接使用weak_ptr访问对象，必须调用lock()，如果对象存在就返回一个指向该对象的shared_ptr，这样就可以访问该对象。</p></li></ul><h4 id="右值引用和移动语义"><a href="#右值引用和移动语义" class="headerlink" title="右值引用和移动语义"></a>右值引用和移动语义</h4><p>移动语义：使用移动操作替换复制操作。实际上的移动操作就是<strong>指针的浅拷贝</strong>。因此只有在对象中拥有指针时，移动操作才会比拷贝操作更快。<br>右值引用：</p><ul><li>左值：能够出现在等号左边的值</li><li>右值：</li></ul><p>右值引用只能绑定在临时对象上，该对象将要被销毁，并且该对象没有其他用户。</p><h5 id="move与forward"><a href="#move与forward" class="headerlink" title="move与forward"></a>move与forward</h5><p>move函数强制将实参转换为右值。<br>forward函数则是只在特定的条件下才实施这样的强制型别转换。：仅当实参是使用<strong>右值</strong>完成初始化时，它才会指向向右值型别的强制类型转换。也就是说forward会保持类型信息。</p><h4 id="四种强制类型转换区别"><a href="#四种强制类型转换区别" class="headerlink" title="四种强制类型转换区别"></a>四种强制类型转换区别</h4><ul><li><strong>const_cast</strong>：将对象的常量性移除。const_cast只能改变对象的底层const。<ul><li>对于<strong>局部常量</strong>，即在函数内部定义的常量，它们位于栈中，去除指针的底层const后，可以对该地址的值进行修改。</li><li>对于<strong>全局常量</strong>，即在全局作用域中定义的常量，它们位于全局区中，通过去除指针的底层const后，仍然不能对该地址的值进行修改。<br>```cpp<br>const int a=7;<br>const int* p=&amp;a;  //底层const，指向的对象是const<br>int *pc=const_cast&lt;int*&gt; (p);</li></ul></li></ul><p> *pc=5;</p><p> ``` </p><ul><li><strong>static_cast</strong>：可以执行任何<strong>具有明确定义</strong>的类型转换，<strong>除了去除const以外</strong>。</li><li><strong>reinterpret_cast</strong>：执行低级转型，如 将int转换为int*。改变对于内存值的读取方式。</li><li><strong>dynamic_cast</strong>：执行<strong>安全的向下转型</strong>，决定某个对象是否归属于继承体系中的某个类型。<br>使用情景：有时我们希望调用子类的成员函数，但是我们只有一个指向父类的指针或引用，这时我们可以通过dynamic_cast将父类类型的指针转型为子类类型的指针。<br>虽然，这个操作我们也可以通过static_cast完成，但是这样做并不保证安全，因为static_cast无法确定转换后的类型是否在该继承体系中。即dynamic_cast在继承体系中的下行类型转换过程中，会进行类型检查，可也保证<strong>安全的向下转型</strong>。<br>但是，dynamic_cast会耗费大量时间进行类型比较，因此我们要尽量避免使用dynamic_cast。</li></ul><h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><p>test</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>throw抛出异常。之后，throw之后的语句将不再被执行，程序的控制权由throw语句转移到对应的catch模块。<br>当控制权发生转移后，</p><ul><li>沿着调用链的函数可能会提早退出</li><li>一旦程序开始执行异常处理代码，那么沿着调用链创建的对象将被销毁。</li></ul><p>之后，开始执行栈展开，逐层向外层检查catch子句。<br>在检查catch子句与抛出的异常对象类型是否匹配时，必须要能够识别该异常对象的类型。<strong>因此编译器必须生成类型描述器，对异常类型进行编码。在执行期，将抛出的异常的类型描述器与catch子句的类型描述器进行比较，当匹配时或者是函数调用栈为空时结束。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面经" scheme="http://www.luckyzmj.cn/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="C++" scheme="http://www.luckyzmj.cn/tags/C/"/>
    
    <category term="面经" scheme="http://www.luckyzmj.cn/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>msvc中类对象的大小</title>
    <link href="http://www.luckyzmj.cn/posts/481f7637.html"/>
    <id>http://www.luckyzmj.cn/posts/481f7637.html</id>
    <published>2021-09-20T14:40:00.136Z</published>
    <updated>2021-09-21T06:31:47.055Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="msvc中类对象的大小"><a href="#msvc中类对象的大小" class="headerlink" title="msvc中类对象的大小"></a>msvc中类对象的大小</h1><p>本文主要来介绍一下在msvc编译器中，类对象的内存分配问题。</p><p><strong>test1</strong> 空类</p><pre class="line-numbers language-none"><code class="language-none">class A {public:};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><a href="https://imgtu.com/i/4JsO2T"><img src="https://z3.ax1x.com/2021/09/21/4JsO2T.png"></a><br>如果一个类是空类，那么编译器会为它分配一个字符量，这样空类的大小就为1。</p><p><strong>test2</strong>  不含虚函数的类</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> a<span class="token punctuation">;</span>    <span class="token keyword">double</span> x<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>   <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在计算类对象的大小时需要考虑<strong>字节对齐</strong>。</p><ul><li><strong>数据成员的字节对齐</strong>：每个非静态数据成员的偏移量应该是其本身类型大小的整数倍。</li><li><strong>整体对象的字节对齐</strong>：最终该类对象的大小应该是其非静态数据成员的最大类型大小的整数倍。</li></ul><p>因此，在考虑字节对齐的情况下，本例中，类A的大小即为（1(char成员1字节)+7(字节对齐)+8(double成员 8字节)=16字节）。<br><a href="https://imgtu.com/i/4JyQit"><img src="https://z3.ax1x.com/2021/09/21/4JyQit.png"></a><br>对象内存分布如下：</p><pre class="line-numbers language-none"><code class="language-none">class Asize(16):1&gt;+---1&gt; 0| a1&gt;  | &lt;alignment member&gt; (size=7)1&gt; 8| x1&gt;+---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>test3</strong> 含有虚函数的类</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">char</span> a<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>   <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于在本例中，该类A含有虚函数，因此类对象的首部会存在一个指向虚函数表的指针。因此该类对象的大小为 4(虚表指针4字节)+1(char成员1字节)+3(字节对齐)=8字节。</p><pre class="line-numbers language-none"><code class="language-none">class Asize(8):1&gt;+---1&gt; 0| {vfptr}1&gt; 4| a1&gt;  | &lt;alignment member&gt; (size=3)1&gt;+---1&gt;A::$vftable@:1&gt;| &amp;A_meta1&gt;|  01&gt; 0| &amp;A::print1&gt;A::print this adjustor: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>test4</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">char</span> a<span class="token punctuation">;</span>    <span class="token keyword">double</span> x<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>   <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当对象内存在double类型，或者更大类型的数据成员时，虚表指针的大小就会变为8字节，<strong>可能是字节对齐的原因</strong>，目前没有找到合理的解释。<br>在本例中，该类对象A的大小是 8(虚表指针)+1(char1字节)+7(字节对齐)+8(double8字节)=24字节<br><a href="https://imgtu.com/i/4JyGQS"><img src="https://z3.ax1x.com/2021/09/21/4JyGQS.png"></a></p><pre class="line-numbers language-none"><code class="language-none">class Asize(24):1&gt;+---1&gt; 0| {vfptr}1&gt; 8| c1&gt;  | &lt;alignment member&gt; (size=7)1&gt;16| x1&gt;+---1&gt;A::$vftable@:1&gt;| &amp;A_meta1&gt;|  01&gt; 0| &amp;A::print1&gt;A::print this adjustor: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>test5</strong>  多重继承</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">double</span> z<span class="token punctuation">;</span>    <span class="token keyword">double</span> zz<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>   <span class="token keyword">char</span> c<span class="token punctuation">;</span>   <span class="token keyword">double</span> x<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>   <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">C</span><span class="token punctuation">,</span><span class="token keyword">public</span> <span class="token class-name">A</span></span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当某个类对象同时继承多个类时(即多重继承)，则<strong>父类中有虚函数的类对象位于前面，没有虚函数的类对象位于后面</strong>。<br>在本例中，如果类A中没有虚函数，那么类C应该位于类B的前部，但是由于A中包含虚函数，因此类A在前，类C在后。<br>类B大小： 24(类A大小24字节)+16(类C大小16字节)+4(int成员变量4字节)+4(字节对齐4字节)=48字节<br><a href="https://imgtu.com/i/4JyUds"><img src="https://z3.ax1x.com/2021/09/21/4JyUds.png"></a></p><pre class="line-numbers language-none"><code class="language-none">1&gt;class Bsize(48):1&gt;+---1&gt; 0| +--- (base class A)1&gt; 0| | {vfptr}1&gt; 8| | c1&gt;  | | &lt;alignment member&gt; (size=7)1&gt;16| | x1&gt;| +---1&gt;24| +--- (base class C)1&gt;24| | z1&gt;32| | zz1&gt;| +---1&gt;40| c1&gt;  | &lt;alignment member&gt; (size=4)1&gt;+---1&gt;B::$vftable@:1&gt;| &amp;B_meta1&gt;|  01&gt; 0| &amp;B::print1&gt;B::print this adjustor: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>test6</strong> 单一虚继承<br>对于虚继承，虚基类位于子类的末尾位置，不考虑字节对齐。在子类部分的首部(不包括继承其他类的部分)有一个指向该虚基类的虚指针。该虚指针的对齐方式与前面的虚表指针一样。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">char</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>   <span class="token keyword">char</span> az<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">C</span></span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> ca<span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">double</span> s<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">1&gt;class Bsize(25):1&gt;+---1&gt; 0| +--- (base class C)1&gt; 0| | s1&gt;| +---1&gt; 4| {vbptr}1&gt; 9| ca1&gt;  | &lt;alignment member&gt; (size=2)1&gt;12| a1&gt;16| s1&gt;+---1&gt;+--- (virtual base A)1&gt;24| az1&gt;+---1&gt;B::$vbtable@:1&gt; 0| -41&gt; 1| 20 (Bd(B+4)A)1&gt;vbi:   class  offset o.vbptr  o.vbte fVtorDisp1&gt;               A      24       4       4 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于此对象模型的解释，可以从以下这篇文章得到一个大概的解释。<br><a href="https://blog.csdn.net/chengonghao/article/details/51679743">https://blog.csdn.net/chengonghao/article/details/51679743</a></p><p>首先，类C在首部，大小为1个字节，而后就是虚指针，由于虚指针需要保证字节对齐，因此首先要在虚指针前面添加三个字节，保证指针字节对齐，又由于类B需要虚指针整体字节对齐，因此需要在虚指针后面添加一个字节，保证虚指针整体大小为8个字节。<br>因此，类B的大小为(1(类C 1字节)+3(字节对齐3字节)+4(虚指针4字节)+1(字节对齐)+1(char1字节)+2(字节对齐)+4(int4字节)+8(double 4字节))=25字节。</p><p><strong>test7</strong> 菱形继承（含有虚继承）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>   <span class="token keyword">char</span> az<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">A</span></span><span class="token punctuation">{</span>    <span class="token keyword">char</span> ca<span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">double</span> s<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">A</span></span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> ca<span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">double</span> s<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">E</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">C</span><span class="token punctuation">,</span><span class="token keyword">public</span> <span class="token class-name">B</span></span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    B b<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>E<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在本例中，类B和类C都虚继承类A，而类E有继承类B和类C。</p><p>类E的大小为 24(类C不包含虚基类的部分的大小)+24(类B不包含虚基类的部分的大小)+4(int4字节)+4(字节对齐4字节)+1(虚基类A1字节)=57字节</p><p><a href="https://imgtu.com/i/4JyDzT"><img src="https://z3.ax1x.com/2021/09/21/4JyDzT.png"></a></p><pre class="line-numbers language-none"><code class="language-none">1&gt;class Esize(57):1&gt;+---1&gt; 0| +--- (base class C)1&gt; 0| | {vbptr}1&gt; 8| | ca1&gt;  | | &lt;alignment member&gt; (size=3)1&gt;12| | a1&gt;16| | s1&gt;| +---1&gt;24| +--- (base class B)1&gt;24| | {vbptr}1&gt;32| | ca1&gt;  | | &lt;alignment member&gt; (size=3)1&gt;36| | a1&gt;40| | s1&gt;| +---1&gt;48| a1&gt;  | &lt;alignment member&gt; (size=4)1&gt;+---1&gt;+--- (virtual base A)1&gt;56| az1&gt;+---1&gt;E::$vbtable@C@:1&gt; 0| 01&gt; 1| 56 (Ed(C+0)A)1&gt;E::$vbtable@B@:1&gt; 0| 01&gt; 1| 32 (Ed(B+0)A)1&gt;vbi:   class  offset o.vbptr  o.vbte fVtorDisp1&gt;               A      56       0       4 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>test8</strong> 虚继承+虚函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> t<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">double</span> i <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">t</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">A</span></span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> t1<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">A</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">t1</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>   <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B2"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    B <span class="token function">b</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    A<span class="token operator">*</span> a <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>    a<span class="token operator">-&gt;</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当对象中同时用于虚函数指针和虚基类指针时，虚函数指针在前面。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">1</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token number">1</span><span class="token operator">&gt;</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">&gt;</span> <span class="token number">0</span><span class="token operator">|</span> <span class="token punctuation">{</span>vfptr<span class="token punctuation">}</span><span class="token number">1</span><span class="token operator">&gt;</span> <span class="token number">4</span><span class="token operator">|</span> <span class="token punctuation">{</span>vbptr<span class="token punctuation">}</span><span class="token number">1</span><span class="token operator">&gt;</span> <span class="token number">8</span><span class="token operator">|</span> t1<span class="token number">1</span><span class="token operator">&gt;</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">&gt;</span><span class="token number">12</span><span class="token operator">|</span> <span class="token punctuation">(</span>vtordisp <span class="token keyword">for</span> vbase A<span class="token punctuation">)</span>  <span class="token comment">//?</span><span class="token number">1</span><span class="token operator">&gt;</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">virtual</span> base A<span class="token punctuation">)</span><span class="token number">1</span><span class="token operator">&gt;</span><span class="token number">16</span><span class="token operator">|</span> <span class="token punctuation">{</span>vfptr<span class="token punctuation">}</span><span class="token number">1</span><span class="token operator">&gt;</span><span class="token number">24</span><span class="token operator">|</span> t<span class="token number">1</span><span class="token operator">&gt;</span>  <span class="token operator">|</span> <span class="token operator">&lt;</span>alignment member<span class="token operator">&gt;</span> <span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token number">1</span><span class="token operator">&gt;</span><span class="token number">32</span><span class="token operator">|</span> i<span class="token number">1</span><span class="token operator">&gt;</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">&gt;</span>B<span class="token operator">::</span>$vftable@B@<span class="token operator">:</span><span class="token number">1</span><span class="token operator">&gt;</span><span class="token operator">|</span> <span class="token operator">&amp;</span>B_meta<span class="token number">1</span><span class="token operator">&gt;</span><span class="token operator">|</span>  <span class="token number">0</span><span class="token number">1</span><span class="token operator">&gt;</span> <span class="token number">0</span><span class="token operator">|</span> <span class="token operator">&amp;</span>B<span class="token operator">::</span>print2<span class="token number">1</span><span class="token operator">&gt;</span>B<span class="token operator">::</span>$vbtable@<span class="token operator">:</span><span class="token number">1</span><span class="token operator">&gt;</span> <span class="token number">0</span><span class="token operator">|</span> <span class="token operator">-</span><span class="token number">4</span><span class="token number">1</span><span class="token operator">&gt;</span> <span class="token number">1</span><span class="token operator">|</span> <span class="token number">12</span> <span class="token punctuation">(</span><span class="token function">Bd</span><span class="token punctuation">(</span>B<span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">)</span>A<span class="token punctuation">)</span><span class="token number">1</span><span class="token operator">&gt;</span>B<span class="token operator">::</span>$vftable@A@<span class="token operator">:</span><span class="token number">1</span><span class="token operator">&gt;</span><span class="token operator">|</span> <span class="token operator">-</span><span class="token number">16</span><span class="token number">1</span><span class="token operator">&gt;</span> <span class="token number">0</span><span class="token operator">|</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>vtordisp<span class="token punctuation">)</span> B<span class="token operator">::</span>print<span class="token number">1</span><span class="token operator">&gt;</span>B<span class="token operator">::</span>print <span class="token keyword">this</span> adjustor<span class="token operator">:</span> <span class="token number">16</span><span class="token number">1</span><span class="token operator">&gt;</span>B<span class="token operator">::</span>print2 <span class="token keyword">this</span> adjustor<span class="token operator">:</span> <span class="token number">0</span><span class="token number">1</span><span class="token operator">&gt;</span>vbi<span class="token operator">:</span>   <span class="token keyword">class</span>  <span class="token class-name">offset</span> o<span class="token punctuation">.</span>vbptr  o<span class="token punctuation">.</span>vbte fVtorDisp<span class="token number">1</span><span class="token operator">&gt;</span>               A      <span class="token number">16</span>       <span class="token number">4</span>       <span class="token number">4</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++篇" scheme="http://www.luckyzmj.cn/categories/C-%E7%AF%87/"/>
    
    
    <category term="C++" scheme="http://www.luckyzmj.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++内存分区</title>
    <link href="http://www.luckyzmj.cn/posts/14b8e558.html"/>
    <id>http://www.luckyzmj.cn/posts/14b8e558.html</id>
    <published>2021-09-20T10:03:51.528Z</published>
    <updated>2021-09-21T06:31:56.279Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="windows下C-的内存分区"><a href="#windows下C-的内存分区" class="headerlink" title="windows下C++的内存分区"></a>windows下C++的内存分区</h1><h3 id="五大分区"><a href="#五大分区" class="headerlink" title="五大分区"></a>五大分区</h3><p>在windows中五大分区地址由高至低依次是：</p><ul><li>堆区：由用户主动申请</li><li>栈区：由高地址向低地址生长，编译器自动分配。存放局部变量、局部常量</li><li>全局区：存放全局变量，全局静态变量、局部静态变量。</li><li>常量区：存放<strong>文字常量</strong>、全局常量、全局静态常量、局部静态常量。</li><li>代码区：存放程序代码。</li></ul><p>其中常量区和代码区都是只可读不可写。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> a1 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">//全局常量</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> a2 <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>  <span class="token comment">//全局静态常量</span><span class="token keyword">static</span> <span class="token keyword">int</span> a3 <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>  <span class="token comment">//全局静态变量</span><span class="token keyword">int</span> a4 <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>       <span class="token comment">//全局变量</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s <span class="token operator">=</span> <span class="token string">"32"</span><span class="token punctuation">;</span> <span class="token comment">//文字常量</span>    <span class="token keyword">int</span> a5 <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span> <span class="token comment">//局部变量</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> a6 <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token comment">//局部常量</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> a7 <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>   <span class="token comment">//局部静态常量</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> a8 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>   <span class="token comment">//局部静态变量</span>    <span class="token keyword">int</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> p3 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>a3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> p4 <span class="token operator">=</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a4<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> p5 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>a5<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> p6 <span class="token operator">=</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a6<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> p7 <span class="token operator">=</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a7<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> p8 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>a8<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> p9 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//堆中申请的局部变量</span>    <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> p10 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//堆中申请的局部常量</span>    <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>测试结果</strong><br><a href="https://imgtu.com/i/4Gq3Xd"><img src="https://z3.ax1x.com/2021/09/20/4Gq3Xd.png"></a></p><p>由以上测试结果可得，各中类型数据所在的位置分布</p><table><thead><tr><th>类型</th><th>地址</th><th>所在分区</th></tr></thead><tbody><tr><td>堆局部常量</td><td>0x011775a8</td><td>堆区</td></tr><tr><td>堆局部变量</td><td>0x01170588</td><td>堆区</td></tr><tr><td>局部变量</td><td>0x00faf6fc</td><td>栈区</td></tr><tr><td>局部常量</td><td>0x00faf6f0</td><td>栈区</td></tr><tr><td>局部静态变量</td><td>0x00eaa008</td><td>全局区</td></tr><tr><td>静态全局变量</td><td>0x00eaa004</td><td>全局区</td></tr><tr><td>全局变量</td><td>0x00eaa000</td><td>全局区</td></tr><tr><td>文字常量</td><td>0x00ea7b40</td><td>常量区</td></tr><tr><td>局部静态常量</td><td>0x00ea7b38</td><td>常量区</td></tr><tr><td>全局静态常量</td><td>0x00ea7b34</td><td>常量区</td></tr><tr><td>全局常量</td><td>0x00ea7b30</td><td>常量区</td></tr></tbody></table><p>这样我们就得到了不同类型数据的内存分布位置。</p><p>并且我们还可以知道 由于a5先于a6定义，而a5的地址高于a6可以知道，<strong>栈内存是从高地址向地址生长的</strong>。<br>我们可以进一步测试：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a1<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a3 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a4 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a3<span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a4 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://imgtu.com/i/4GqNAP"><img src="https://z3.ax1x.com/2021/09/20/4GqNAP.png"></a><br>可以明显知道，变量a1到a4地址逐个降低，进一步说明了<strong>栈内存是从高地址向低地址生长</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++篇" scheme="http://www.luckyzmj.cn/categories/C-%E7%AF%87/"/>
    
    
    <category term="C++" scheme="http://www.luckyzmj.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>型别推导</title>
    <link href="http://www.luckyzmj.cn/posts/89c1cd20.html"/>
    <id>http://www.luckyzmj.cn/posts/89c1cd20.html</id>
    <published>2021-09-20T10:00:19.195Z</published>
    <updated>2021-09-21T06:31:35.463Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="型别推导"><a href="#型别推导" class="headerlink" title="型别推导"></a>型别推导</h1><h3 id="模板中的型别推导规则"><a href="#模板中的型别推导规则" class="headerlink" title="模板中的型别推导规则"></a>模板中的型别推导规则</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>Paramtype param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>以上是模板和调用的一般形式。<br>现在我们需要考虑在模板型别推导过程中出现的一般情况。</p><ul><li><p>Paramtype 是个指针或者引用，但不是万能引用。<br>在这种情况下，型别推导将会按照如下过程运作：</p><ul><li>如果expr具有引用，则<strong>将引用忽略</strong>。（在形参类型不是万能引用的情况下，实参类型是否具有引用对于形参的类型并无影响）</li><li>将忽略引用后的expr与Paramtype 进行模式匹配，推导出T的类型。</li></ul></li><li><p>Paramtype是个万能引用。</p><ul><li> 如果expr是个左值，T和Paramtype都会被推导为左值引用。</li><li> 如果expr是个右值，则应用第一种情况的规则。</li></ul></li><li><p>Paramtype既不是指针也不是引用。<br>这也就意味着在这种情况下采用传值的方式。由于在传值的情况下，形参都是实参的副本，这样在进行型别推导时就需要忽略实参的引用以及const和volatile。</p></li><li><p>在模板型别推导过程中，数组或函数型别的实参会退化成对应的指针，除非他们被用来初始化引用。</p></li></ul><h3 id="auto-型别推导"><a href="#auto-型别推导" class="headerlink" title="auto 型别推导"></a>auto 型别推导</h3><p>auto将等号右边的值看做实参，进行型别推导。其推导规则与模板型别推导基本一致。<br>auto型别推导与模板型别推导的唯一不同就是当采用<strong>列表初始化</strong>的方式初始化变量时，该变量的类型会被推导为initializer_list&lt; T&gt;。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> a<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//a的类型被推导为initializer_list&lt;int&gt;</span><span class="token keyword">auto</span> a1<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1.0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//由于大括号中的值类型不一致，因此无法推导出initializer_list&lt;T&gt; 中的T</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="decltype-型别推导"><a href="#decltype-型别推导" class="headerlink" title="decltype 型别推导"></a>decltype 型别推导</h3><ul><li>在绝大多数情况下，decltype会得出变量或表达式的型别而不做任何修改。</li><li>对于型别为T的表达式，除非该表达式仅有一个名字，decltype总是得出型别T&amp;。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++篇" scheme="http://www.luckyzmj.cn/categories/C-%E7%AF%87/"/>
    
    
    <category term="C++" scheme="http://www.luckyzmj.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>解析vector在msvc中的增长方式</title>
    <link href="http://www.luckyzmj.cn/posts/8544f5f8.html"/>
    <id>http://www.luckyzmj.cn/posts/8544f5f8.html</id>
    <published>2021-08-14T16:00:00.000Z</published>
    <updated>2021-09-21T06:32:09.542Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="解析vector在msvc中的增长方式"><a href="#解析vector在msvc中的增长方式" class="headerlink" title="解析vector在msvc中的增长方式"></a>解析vector在msvc中的增长方式</h1><p><a href="https://imgtu.com/i/48WeMT"><img src="https://z3.ax1x.com/2021/09/20/48WeMT.jpg"></a></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>首先，我们在vs2019中对于vector的增长方式进行测试。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"    "</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>结果</strong><br><a href="https://imgtu.com/i/4GoZjI"><img src="https://z3.ax1x.com/2021/09/20/4GoZjI.png"></a></p><p>由图中结果可以看出，每次重新分配空间，<strong>vector的容量增长了原容量的一半。</strong></p><h3 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a>分析源码</h3><p>首先，调用push_back函数。<br><a href="https://imgtu.com/i/4Go83j"><img src="https://z3.ax1x.com/2021/09/20/4Go83j.png"></a><br>在<strong>push_back</strong>函数内部调用<strong>emplace_back</strong>。<br><a href="https://imgtu.com/i/4GogDx"><img src="https://z3.ax1x.com/2021/09/20/4GogDx.png"></a><br>而在emplace_back内部，当容量不足时，会调用 <strong>_Emplace_reallocate</strong>函数，来重新分配内存空间。<br><a href="https://imgtu.com/i/4GoND0"><img src="https://z3.ax1x.com/2021/09/20/4GoND0.png"></a><br>在该函数内部，会更新size与capacity的值。通过函数 <strong>_Calculate_growth</strong>来计算vector新的容量值。<br><a href="https://imgtu.com/i/4Goh5D"><img src="https://z3.ax1x.com/2021/09/20/4Goh5D.png"></a></p><ul><li>如果旧容量与旧容量的1/2的和超过了所能分配的最大内存，则返回该最大内存的值。</li><li>否则，将新内存更新为旧容量与旧容量的1/2的和。即<strong>容量增长了原容量的一半。</strong></li><li>如果增长后的容量值仍不足，则将容量更新为_Newsize。即<strong>如果一次性在vector中添加了超过原容量的1/2的数据，那么新容量的值就是添加数据所占的容量与原容量的和，即不预留额外空间。</strong></li></ul><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>从以上测试结果，以及对于源码的分析可以看出，vector每次增长原容量的一半。那么这么做的原因是什么呢？<br>C++ STL 中 vector 内存用尽后, 为什么每次是 2 倍的增长, 而不是 3 倍或其他值? - Milo Yip的回答 - 知乎<br><a href="https://www.zhihu.com/question/36538542/answer/67994276">https://www.zhihu.com/question/36538542/answer/67994276</a></p><p>如果采用2倍增长的策略，由于每次新分配的内存必定大于之前所分配内存的总和，这样之前缓存就永远无法被利用。而如果采用1.5倍增长的话，理论上就可以利用之前分配过的缓存（<strong>缓存友好</strong>）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++篇" scheme="http://www.luckyzmj.cn/categories/C-%E7%AF%87/"/>
    
    
    <category term="C++" scheme="http://www.luckyzmj.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>解析迭代器</title>
    <link href="http://www.luckyzmj.cn/posts/b67a3ab3.html"/>
    <id>http://www.luckyzmj.cn/posts/b67a3ab3.html</id>
    <published>2020-03-14T16:00:00.000Z</published>
    <updated>2021-09-21T06:32:20.383Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h3 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h3><p>向容器中添加元素：</p><ul><li>如果容器是vector或string，并且重新分配内存空间，那么所有迭代器、指针、引用都会失效。如果没有重新分配内存，那么在添加元素位置之后的迭代器、指针、引用都会失效。</li><li>如果容器是deque，那么插入到除首尾之外的任何位置都会导致迭代器、指针、引用失效。插入到首尾位置，迭代器会失效。</li><li>如果容器是list和forward_list，指向容器的迭代器、指针和引用仍有效。</li></ul><p>从容器中删除元素：</p><ul><li>如果容器是list和forward_list，指向容器其他位置的迭代器、引用、指针仍然有效。</li><li>对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器失效，但其他迭代器、指针和引用不会失效。如果是删除首元素，这些也不会受影响。</li><li>对于vector和string，指向被删除元素之前元素的迭代器、引用指针仍有效。</li></ul><h3 id="迭代器失效原因"><a href="#迭代器失效原因" class="headerlink" title="迭代器失效原因"></a>迭代器失效原因</h3><p>迭代器之所以会失效是由于迭代器原本指向的对象的地址发生改变，导致迭代器所存储的地址中的对象将不再正确。</p><ul><li><p>在<strong>vector</strong>和<strong>string</strong>中，如果<strong>重新分配内存</strong>，那么其中所有元素的地址都会发生改变。那么我们在这之前所获得的迭代器指向的对象则发生改变，如果我们仍然继续使用这些迭代器，将会导致严重的错误。如果没有重新分配内存，那么在该位置之后元素需要全部后移，那么指向这些元素的迭代器当然也会失效。</p></li><li><p>在<strong>deque</strong>中，由于deque的底层实现方式比较特殊，因此其迭代器可能失效的情况也与vector和string不太一样。<br>如果在deque的首部或者尾部插入元素：</p><ul><li>首先，由于deque的特殊设计，deque的内部元素不会发生移动，那么这些元素的指针和引用便不会失效。但是由于在首部或尾部添加元素可能会导致deque增加新的<strong>chunk</strong>，这就会导致其迭代器失效。</li><li>而如果要在deque内部插入元素的话，那么其他元素都可能会发生移动，因此这些元素的迭代器、指针和引用都会失效。</li></ul></li><li><p>在<strong>list</strong>中，由于list是环形链表，因此无论是执行插入还是删除操作都不会改变其元素的地址，因此list中的迭代器、指针和引用不会失效。</p></li></ul><h3 id="msvc能够检测迭代器是否失效"><a href="#msvc能够检测迭代器是否失效" class="headerlink" title="msvc能够检测迭代器是否失效"></a>msvc能够检测迭代器是否失效</h3><p>msvc在debug模式下可以检测迭代器是否失效。<br>检测方法：<br>c++标准库是如何实现迭代器失效的？ - rayhunter的回答 - 知乎<br><a href="https://www.zhihu.com/question/460078504/answer/1893604802">https://www.zhihu.com/question/460078504/answer/1893604802</a><br>通过一个隐式的迭代器链表来检测迭代器是否失效。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++篇" scheme="http://www.luckyzmj.cn/categories/C-%E7%AF%87/"/>
    
    
    <category term="C++" scheme="http://www.luckyzmj.cn/tags/C/"/>
    
  </entry>
  
</feed>
