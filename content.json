{"meta":{"title":"Luckey","subtitle":"LoveZDF博客","description":"本科 | 计算机科学与技术 | 网络安全","author":"Luckey","url":"http://www.luckyzmj.cn","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-09-19T10:33:51.039Z","comments":true,"path":"404.html","permalink":"http://www.luckyzmj.cn/404.html","excerpt":"","text":""},{"title":"","date":"2021-09-19T10:36:51.338Z","updated":"2021-09-19T10:33:51.139Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"http://www.luckyzmj.cn/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"","date":"2021-09-19T10:36:51.344Z","updated":"2021-09-19T10:33:51.143Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"http://www.luckyzmj.cn/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-09-19T10:33:51.051Z","comments":true,"path":"List/index.html","permalink":"http://www.luckyzmj.cn/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-09-19T10:33:51.139Z","comments":true,"path":"about/index.html","permalink":"http://www.luckyzmj.cn/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-09-19T10:33:51.139Z","comments":true,"path":"archives/index.html","permalink":"http://www.luckyzmj.cn/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2021-09-19T10:33:51.141Z","comments":true,"path":"categories/index.html","permalink":"http://www.luckyzmj.cn/categories/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-09-19T10:33:51.142Z","comments":true,"path":"census/index.html","permalink":"http://www.luckyzmj.cn/census/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2021-09-19T10:33:51.142Z","comments":true,"path":"contact/index.html","permalink":"http://www.luckyzmj.cn/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 Luckeyの友链信息 博客名称: Luckeyの博客 博客网址: http://www.luckyzmj.cn 博客头像: https://s1.ax1x.com/2020/05/17/YRWsYT.png 博客介绍: The harder you work, the luckier you will be"},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2021-09-19T10:33:51.143Z","comments":true,"path":"friends/index.html","permalink":"http://www.luckyzmj.cn/friends/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-09-19T10:33:51.144Z","comments":true,"path":"resource/index.html","permalink":"http://www.luckyzmj.cn/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-09-19T10:33:51.145Z","comments":true,"path":"tags/index.html","permalink":"http://www.luckyzmj.cn/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-09-19T10:33:51.044Z","updated":"2021-09-19T10:33:51.044Z","comments":true,"path":"List/galleries/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-09-19T10:33:51.051Z","comments":true,"path":"List/movies/index.html","permalink":"http://www.luckyzmj.cn/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-09-19T10:33:51.052Z","comments":true,"path":"List/tools/index.html","permalink":"http://www.luckyzmj.cn/List/tools/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-09-19T10:33:51.052Z","comments":true,"path":"List/music/index.html","permalink":"http://www.luckyzmj.cn/List/music/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2021-09-19T10:33:51.044Z","updated":"2021-09-19T10:33:51.044Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2021-09-19T10:33:51.046Z","updated":"2021-09-19T10:33:51.046Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2021-09-19T10:33:51.045Z","updated":"2021-09-19T10:33:51.045Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2021-09-19T10:33:51.046Z","updated":"2021-09-19T10:33:51.046Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2021-09-19T10:33:51.045Z","updated":"2021-09-19T10:33:51.045Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2021-09-19T10:33:51.048Z","updated":"2021-09-19T10:33:51.048Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2021-09-19T10:33:51.047Z","updated":"2021-09-19T10:33:51.047Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2021-09-19T10:33:51.048Z","updated":"2021-09-19T10:33:51.048Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2021-09-19T10:33:51.049Z","updated":"2021-09-19T10:33:51.049Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2021-09-19T10:33:51.049Z","updated":"2021-09-19T10:33:51.049Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2021-09-19T10:33:51.050Z","updated":"2021-09-19T10:33:51.050Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2021-09-19T10:33:51.050Z","updated":"2021-09-19T10:33:51.050Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""}],"posts":[{"title":"C++内存分区","slug":"对于c++ 内存分区的讨论","date":"2021-09-20T10:03:51.528Z","updated":"2021-09-20T13:31:12.852Z","comments":true,"path":"posts/14b8e558.html","link":"","permalink":"http://www.luckyzmj.cn/posts/14b8e558.html","excerpt":"","text":"windows下C++的内存分区五大分区在windows中五大分区地址由高至低依次是： 堆区：由用户主动申请 栈区：由高地址向低地址生长，编译器自动分配。存放局部变量、局部常量 全局区：存放全局变量，全局静态变量、局部静态变量。 常量区：存放文字常量、全局常量、全局静态常量、局部静态常量。 代码区：存放程序代码。 其中常量区和代码区都是只可读不可写。 测试const int a1 = 5; //全局常量 static const int a2 = 11; //全局静态常量 static int a3 = 12; //全局静态变量 int a4 = 6; //全局变量 void main() { const char* s = \"32\"; //文字常量 int a5 = 7; //局部变量 const int a6 = 8;//局部常量 static const int a7 = 9; //局部静态常量 static int a8 = 10; //局部静态变量 int* p1 = const_cast&lt;int*&gt;(&amp;a1); int* p2 = const_cast&lt;int*&gt;(&amp;a2); int* p3 = (&amp;a3); int* p4 = const_cast&lt;int*&gt;(&amp;a4); int* p5 = (&amp;a5); int* p6 = const_cast&lt;int*&gt;(&amp;a6); int* p7 = const_cast&lt;int*&gt;(&amp;a7); int* p8 = (&amp;a8); int* p9 = new int(11); //堆中申请的局部变量 const int* p10 = new int(12); //堆中申请的局部常量 *p2 = 3; } 测试结果 由以上测试结果可得，各中类型数据所在的位置分布 类型 地址 所在分区 堆局部常量 0x011775a8 堆区 堆局部变量 0x01170588 堆区 局部变量 0x00faf6fc 栈区 局部常量 0x00faf6f0 栈区 局部静态变量 0x00eaa008 全局区 静态全局变量 0x00eaa004 全局区 全局变量 0x00eaa000 全局区 文字常量 0x00ea7b40 常量区 局部静态常量 0x00ea7b38 常量区 全局静态常量 0x00ea7b34 常量区 全局常量 0x00ea7b30 常量区 这样我们就得到了不同类型数据的内存分布位置。 并且我们还可以知道 由于a5先于a6定义，而a5的地址高于a6可以知道，栈内存是从高地址向地址生长的。我们可以进一步测试： void main() { int a1=1; int a2 = 1; int a3 = 1; int a4 = 1; cout &lt;&lt; &amp;a1 &lt;&lt; endl; cout &lt;&lt; &amp;a2 &lt;&lt; endl; cout &lt;&lt; &amp;a3&lt;&lt; endl; cout &lt;&lt; &amp;a4 &lt;&lt; endl; } 可以明显知道，变量a1到a4地址逐个降低，进一步说明了栈内存是从高地址向低地址生长。","categories":[{"name":"博客篇","slug":"博客篇","permalink":"http://www.luckyzmj.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.luckyzmj.cn/tags/C/"}],"author":"LoveZDF"},{"title":"型别推导","slug":"c++中的型别推导规则","date":"2021-09-20T10:00:19.195Z","updated":"2021-09-20T10:04:11.233Z","comments":true,"path":"posts/89c1cd20.html","link":"","permalink":"http://www.luckyzmj.cn/posts/89c1cd20.html","excerpt":"","text":"型别推导模板中的型别推导规则template &lt;typename T&gt; void f(Paramtype param); f(expr); 以上是模板和调用的一般形式。现在我们需要考虑在模板型别推导过程中出现的一般情况。 Paramtype 是个指针或者引用，但不是万能引用。在这种情况下，型别推导将会按照如下过程运作： 如果expr具有引用，则将引用忽略。（在形参类型不是万能引用的情况下，实参类型是否具有引用对于形参的类型并无影响） 将忽略引用后的expr与Paramtype 进行模式匹配，推导出T的类型。 Paramtype是个万能引用。 如果expr是个左值，T和Paramtype都会被推导为左值引用。 如果expr是个右值，则应用第一种情况的规则。 Paramtype既不是指针也不是引用。这也就意味着在这种情况下采用传值的方式。由于在传值的情况下，形参都是实参的副本，这样在进行型别推导时就需要忽略实参的引用以及const和volatile。 在模板型别推导过程中，数组或函数型别的实参会退化成对应的指针，除非他们被用来初始化引用。 auto 型别推导auto将等号右边的值看做实参，进行型别推导。其推导规则与模板型别推导基本一致。auto型别推导与模板型别推导的唯一不同就是当采用列表初始化的方式初始化变量时，该变量的类型会被推导为initializer_list&lt; T&gt;。 auto a{1}; //a的类型被推导为initializer_list&lt;int&gt; auto a1{1,1.0}; //由于大括号中的值类型不一致，因此无法推导出initializer_list&lt;T&gt; 中的T decltype 型别推导 在绝大多数情况下，decltype会得出变量或表达式的型别而不做任何修改。 对于型别为T的表达式，除非该表达式仅有一个名字，decltype总是得出型别T&amp;。","categories":[{"name":"博客篇","slug":"博客篇","permalink":"http://www.luckyzmj.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.luckyzmj.cn/tags/C/"}],"author":"Luckey"},{"title":"解析vector在msvc中的增长方式","slug":"解析vector","date":"2021-08-14T16:00:00.000Z","updated":"2021-09-20T10:06:22.613Z","comments":true,"path":"posts/8544f5f8.html","link":"","permalink":"http://www.luckyzmj.cn/posts/8544f5f8.html","excerpt":"","text":"解析vector在msvc中的增长方式 测试首先，我们在vs2019中对于vector的增长方式进行测试。 for (int i = 0; i &lt; 100; ++i) { a.push_back(i); cout &lt;&lt; a.capacity() &lt;&lt; \" \"; } 结果 由图中结果可以看出，每次重新分配空间，vector的容量增长了原容量的一半。 分析源码首先，调用push_back函数。在push_back函数内部调用emplace_back。而在emplace_back内部，当容量不足时，会调用 _Emplace_reallocate函数，来重新分配内存空间。在该函数内部，会更新size与capacity的值。通过函数 _Calculate_growth来计算vector新的容量值。 如果旧容量与旧容量的1/2的和超过了所能分配的最大内存，则返回该最大内存的值。 否则，将新内存更新为旧容量与旧容量的1/2的和。即容量增长了原容量的一半。 如果增长后的容量值仍不足，则将容量更新为_Newsize。即如果一次性在vector中添加了超过原容量的1/2的数据，那么新容量的值就是添加数据所占的容量与原容量的和，即不预留额外空间。 原因从以上测试结果，以及对于源码的分析可以看出，vector每次增长原容量的一半。那么这么做的原因是什么呢？C++ STL 中 vector 内存用尽后, 为什么每次是 2 倍的增长, 而不是 3 倍或其他值? - Milo Yip的回答 - 知乎https://www.zhihu.com/question/36538542/answer/67994276 如果采用2倍增长的策略，由于每次新分配的内存必定大于之前所分配内存的总和，这样之前缓存就永远无法被利用。而如果采用1.5倍增长的话，理论上就可以利用之前分配过的缓存（缓存友好）。","categories":[{"name":"博客篇","slug":"博客篇","permalink":"http://www.luckyzmj.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.luckyzmj.cn/tags/C/"}],"author":"LoveZDF"},{"title":"解析迭代器","slug":"解析迭代器","date":"2020-03-14T16:00:00.000Z","updated":"2021-09-20T10:04:11.235Z","comments":true,"path":"posts/b67a3ab3.html","link":"","permalink":"http://www.luckyzmj.cn/posts/b67a3ab3.html","excerpt":"","text":"迭代器迭代器失效向容器中添加元素： 如果容器是vector或string，并且重新分配内存空间，那么所有迭代器、指针、引用都会失效。如果没有重新分配内存，那么在添加元素位置之后的迭代器、指针、引用都会失效。 如果容器是deque，那么插入到除首尾之外的任何位置都会导致迭代器、指针、引用失效。插入到首尾位置，迭代器会失效。 如果容器是list和forward_list，指向容器的迭代器、指针和引用仍有效。 从容器中删除元素： 如果容器是list和forward_list，指向容器其他位置的迭代器、引用、指针仍然有效。 对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器失效，但其他迭代器、指针和引用不会失效。如果是删除首元素，这些也不会受影响。 对于vector和string，指向被删除元素之前元素的迭代器、引用指针仍有效。 迭代器失效原因迭代器之所以会失效是由于迭代器原本指向的对象的地址发生改变，导致迭代器所存储的地址中的对象将不再正确。 在vector和string中，如果重新分配内存，那么其中所有元素的地址都会发生改变。那么我们在这之前所获得的迭代器指向的对象则发生改变，如果我们仍然继续使用这些迭代器，将会导致严重的错误。如果没有重新分配内存，那么在该位置之后元素需要全部后移，那么指向这些元素的迭代器当然也会失效。 在deque中，由于deque的底层实现方式比较特殊，因此其迭代器可能失效的情况也与vector和string不太一样。如果在deque的首部或者尾部插入元素： 首先，由于deque的特殊设计，deque的内部元素不会发生移动，那么这些元素的指针和引用便不会失效。但是由于在首部或尾部添加元素可能会导致deque增加新的chunk，这就会导致其迭代器失效。 而如果要在deque内部插入元素的话，那么其他元素都可能会发生移动，因此这些元素的迭代器、指针和引用都会失效。 在list中，由于list是环形链表，因此无论是执行插入还是删除操作都不会改变其元素的地址，因此list中的迭代器、指针和引用不会失效。 msvc能够检测迭代器是否失效msvc在debug模式下可以检测迭代器是否失效。检测方法：c++标准库是如何实现迭代器失效的？ - rayhunter的回答 - 知乎https://www.zhihu.com/question/460078504/answer/1893604802通过一个隐式的迭代器链表来检测迭代器是否失效。","categories":[{"name":"博客篇","slug":"博客篇","permalink":"http://www.luckyzmj.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.luckyzmj.cn/tags/C/"}],"author":"LoveZDF"}],"categories":[{"name":"博客篇","slug":"博客篇","permalink":"http://www.luckyzmj.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.luckyzmj.cn/tags/C/"}]}