{"meta":{"title":"Lovezdf","subtitle":"LoveZDF的博客","description":"本科 | 数据科学与大数据技术","author":"LoveZDF","url":"http://www.luckyzmj.cn","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-09-19T10:33:51.039Z","comments":true,"path":"404.html","permalink":"http://www.luckyzmj.cn/404.html","excerpt":"","text":""},{"title":"","date":"2021-09-19T10:36:51.338Z","updated":"2021-09-19T10:33:51.139Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"http://www.luckyzmj.cn/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"","date":"2021-09-19T10:36:51.344Z","updated":"2021-09-19T10:33:51.143Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"http://www.luckyzmj.cn/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-09-19T10:33:51.051Z","comments":true,"path":"List/index.html","permalink":"http://www.luckyzmj.cn/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-09-19T10:33:51.139Z","comments":true,"path":"about/index.html","permalink":"http://www.luckyzmj.cn/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2021-09-19T10:33:51.141Z","comments":true,"path":"categories/index.html","permalink":"http://www.luckyzmj.cn/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-09-19T10:33:51.139Z","comments":true,"path":"archives/index.html","permalink":"http://www.luckyzmj.cn/archives/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2021-09-19T10:33:51.142Z","comments":true,"path":"contact/index.html","permalink":"http://www.luckyzmj.cn/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 Luckeyの友链信息 博客名称: Luckeyの博客 博客网址: http://www.luckyzmj.cn 博客头像: https://s1.ax1x.com/2020/05/17/YRWsYT.png 博客介绍: The harder you work, the luckier you will be"},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-09-19T10:33:51.142Z","comments":true,"path":"census/index.html","permalink":"http://www.luckyzmj.cn/census/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2021-09-19T10:33:51.143Z","comments":true,"path":"friends/index.html","permalink":"http://www.luckyzmj.cn/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-09-19T10:33:51.145Z","comments":true,"path":"tags/index.html","permalink":"http://www.luckyzmj.cn/tags/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-09-19T10:33:51.144Z","comments":true,"path":"resource/index.html","permalink":"http://www.luckyzmj.cn/resource/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-09-19T10:33:51.044Z","updated":"2021-09-19T10:33:51.044Z","comments":true,"path":"List/galleries/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-09-19T10:33:51.051Z","comments":true,"path":"List/movies/index.html","permalink":"http://www.luckyzmj.cn/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-09-19T10:33:51.052Z","comments":true,"path":"List/music/index.html","permalink":"http://www.luckyzmj.cn/List/music/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-09-19T10:33:51.052Z","comments":true,"path":"List/tools/index.html","permalink":"http://www.luckyzmj.cn/List/tools/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2021-09-19T10:33:51.044Z","updated":"2021-09-19T10:33:51.044Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2021-09-19T10:33:51.045Z","updated":"2021-09-19T10:33:51.045Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2021-09-19T10:33:51.045Z","updated":"2021-09-19T10:33:51.045Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2021-09-19T10:33:51.046Z","updated":"2021-09-19T10:33:51.046Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2021-09-19T10:33:51.046Z","updated":"2021-09-19T10:33:51.046Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2021-09-19T10:33:51.047Z","updated":"2021-09-19T10:33:51.047Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2021-09-19T10:33:51.048Z","updated":"2021-09-19T10:33:51.048Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2021-09-19T10:33:51.048Z","updated":"2021-09-19T10:33:51.048Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2021-09-19T10:33:51.049Z","updated":"2021-09-19T10:33:51.049Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2021-09-19T10:33:51.049Z","updated":"2021-09-19T10:33:51.049Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2021-09-19T10:33:51.050Z","updated":"2021-09-19T10:33:51.050Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2021-09-19T10:33:51.050Z","updated":"2021-09-19T10:33:51.050Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"C++ 面经","slug":"c++","date":"2021-09-20T14:42:08.009Z","updated":"2021-09-20T16:53:14.487Z","comments":true,"path":"posts/d426d8b5.html","link":"","permalink":"http://www.luckyzmj.cn/posts/d426d8b5.html","excerpt":"","text":"C++ 面经基本语法函数指针引用、指针define define与const的区别 define与inline的区别 static作用 1.修饰局部变量。将对象声明为静态对象。静态对象的生命期一直持续到程序结束。 2.修饰成员变量。将类中的成员变量声明为静态成员变量。这样该类的所有对象共同拥有该成员变量。 3.修饰成员函数。将类中的成员函数声明为静态成员函数。这样不用通过该类的对象也可以直接调用该函数。 4.修饰全局变量。该变量只在本编译单元可见。 5.修饰函数。该函数只在本编译单元可见。 C++、面向对象特性 多态 继承 封装 STL容器vector动态数组 常用方法： push_back：在尾部添加一个元素 emplace_back:传入参数，在尾部直接构造一个新元素 clear assign：将vector的内容替换为参数内容。 reserve：分配至少能容纳n个元素的空间。如果要分配的内存空间小于当前大小，则什么也不做。 数组增长方式：二倍增长，1/4缩小。在msvc中（vs2019）的具体实现是，每次增加原容量的一半，即1.5倍增长。具体内容见另一篇文章。 string字符串字符串的常用方法大部分与vector相似。 构造函数： string s(cp,n); s是cp指向的数组的前n个字符的拷贝。 string s(s2,pos2); s是string s2从下标pos2开始的字符的拷贝。 string s(s2,pos2,len)；s是string s2从下标pos2开始len个字符的拷贝。 substr ：返回string的子串 s.substr(6,11); shrink_to_fit ：通过释放不使用的内存，减少内存的使用。 find :在字符串中寻找子串。 npos：静态成员。size_type类型 特殊值，size_type类型可以表示的最大值。返回string下标的函数将 npos作为错误指示器。 append :在字符串末尾进行插入操作。 replace： s.replace(range,args);删除s中范围range内的字符，替换为args中指定的字符。 map、set multimap、multimap unordered_map 底层实现： map、set：红黑树 unordered_map： 哈希表 迭代器连接容器与算法有的容器的迭代器只是对普通指针的简单封装。如vector。有的容器的迭代器则需要复杂的实现。如deque。迭代器种类： input_iterator output_iterator forward_iterator bidireational_iterator random_access_iterator 迭代器失效问题： 适配器queue队列： 先入先出 stack栈：先入后出 priority_queue优先队列：最大堆、最小堆 模板模板一定要放在头文件吗？模板的声明与定义必须放在同一文件中。因为如果不这样做的话，在模板实例化时编译器就无法找到模板的定义。如果模板的声明与定义没有放在同一文件中，那么在实例化时编译器无法找到模板的定义也就没有实例化模板定义，这样在链接时就会出现链接错误。但是模板并不一定要放在头文件中。 型别推导当我们使用函数模板时并不需要显示声明模板参数的值，这就需要编译器对参数类型进行型别推导，来确定模板参数的值。具体的型别推导规则见另一篇文章。 实例化当我们只是声明一个模板类时，编译器什么也不会做，并不会对该模板进行实例化，不会生成类定义。只有当我们显示或隐式实例化该模板后，编译器才会为实例生成代码，生成类定义，执行实例化。 显式实例化：extern template class test&lt;int&gt;; //实例化声明 template class test&lt;int&gt;; //实例化定义 对于每个实例化声明，在程序中某个位置必须有其显式的实例化定义。显示实例化会实例化模板的所有成员。 隐式实例化：test&lt;int&gt; a(1); 对于模板类的成员函数，只有我们使用到的成员函数才会被生成出来，编译器只会实例化这些使用到的成员函数，并不会实例化所有成员函数。 重载与模板函数模板与函数重载的区别 函数模板可以被另一个模板或一个普通非模板函数重载。与往常一样，名字相同的函数必须具有不同数量或类型的参数。如果涉及函数模板，则函数匹配规则会在以下几方面受到影响： 对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例。 候选的函数模板总是可行的，因为模板实参推断会排除任何不可行的模板。 如果恰有一个函数提供比其他函数都更好的函数匹配，则选择此函数。但是如果有多个函数提供同样好的匹配，则 如果同样好的函数中只有一个是非模板函数，则选择此函数。 如果同样好的函数中没有非模板函数，而有多个函数模板，且其中一个函数模板比其他函数模板更特例化，则选择此模板。 否则，此调用有歧义。 特化特化是由于对于某种特殊的类型需要修改模板的定义，对该类型进行特别处理。函数模板特化就是为所有模板参数指定实参。函数模板特例化的本质是实例化一个模板，而非重载它，因此特例化不影响函数匹配。类模板特例化不用为所有模板参数指定实参。而当有多个模板参数时，就需要考虑是否需要对所有模板参数都特殊化处理。当只对其中部分模板参数进行特殊化处理时，就是 偏特化，对所有模板参数都需要特殊化处理时，就是 全特化。 内存管理C++ 内存分区 代码区：存储代码 数据区(常量区)：存储文字常量 常量字符串、全局常量 全局区（静态区）：存储全局变量、静态数据 栈区: 局部变量、局部常量 堆区:用户申请内存 new、delete:new 和delete都是操作符。auto p=new T(args):先分配内存空间（operator new），在根据参数调用对象的构造函数。delete p:先调用对象的析构函数，再释放内存空间（operator delete）。 new[]、delete []:auto p=new T[3]; 分配空间， 调用3次T的默认构造函数。delete[] p; 调用三次T的析构函数，再释放空间。由此可见，new[]与 delete[]必须对应使用，如果使用 new[]而调用delete释放空间，那么就只会调用一次T的析构函数，这样就会造成内存泄漏。当我们使用new[] 分配内存时，会在分配的内存之前另外分配一个cookie空间来记录长度，这样在调用delete[]时，就可以读取该cookie来知道需要调用几次析构函数。 operator new、operator deleteoperator new与operator delete 是函数。::operator new默认调用malloc。::operator delete默认调用free。我们可以对operator new、operator delete进行重载。 placement new由于我们无法直接调用构造函数，因此如果我们希望在某个内存上直接调用构造函数构造对象，就需要placement new的帮助。placement new是operator new的重载函数。 void* operator new (std::size_t size, void* ptr) throw(); ``` **使用方法** new (p)T(args) 在p指针指向的内存上调用T的构造函数。 ### 对象模型 ##### 对象大小 静态成员变量并不存储在对象内部。因此在计算对象大小时，不需要考虑静态成员变量的大小。 32位： - int 4个字节 - 指针 4个字节（在64位下是8个字节） - char 1个字节 - float 4个字节 - double 8个字节 要求得对象的大小还需要考虑**字节对齐**。 在msvc中字节对齐要满足两个要求： - 每个非静态成员变量的偏移量应该是自己类型大小的整数倍。 - 最终对象大小的值应该是各个非静态成员变量的最大值的倍数 ```cpp #pragma pack(1) 来设置字节对齐值，上面就将字节对齐值设为1。字节对齐的原因： 可以提升CPU访问数据的效率：如果字节不对齐的话，可能要通过两次读取操作才能完成对于数据的读取，但是如果内存对齐的话，只要一次就可以了。 拷贝构造函数、拷贝赋值函数、析构函数在拷贝赋值函数（即operator=）中，注意对于自我赋值的处理。 析构函数为什么要采用虚函数？因为如果通过父类指针调用析构函数，并且该指针指向的是子类对象，并且析构函数不是虚函数的话，就只会析构该子类对象的父类部分，这就会导致错误。 为什么构造函数不能是虚函数？（1）将构造函数定义为虚函数是无意义的。所谓利用虚机制实现运行时多态，实际上是通过指针实际所指对象的不同调用不同的函数。但是如果对象尚未被创建出来，我们就无法获取实际对象的类型信息，也就无法实现动态绑定。（2）如果我们希望通过动态绑定的方式调用构造函数，那么就必须要通过虚指针来实现，但是由于此时对象并为被创建，也就没有虚指针，这样也就无法通过动态绑定来实现对于虚构造函数的调用。因此构造函数无法是虚函数。（3）构造函数是在创建对象时被自动调用的，因此即便我们将构造函数是虚函数，我们也无法通过动态绑定的方式来调用。 为什么不能让析构函数抛出异常?因为在处理异常时，会析构已经构造的对象，如果此时析构函数抛出异常，那么就会同时出现两个异常，C++无法同时处理两个异常，会导致程序直接退出或是未知行为。 编译器为我们编写那些函数？如果我们没有声明构造函数、析构函数、拷贝构造函数或是拷贝赋值函数，编译器会为我们声明它们。并且 当我们调用这些函数时，它们才会被编译器创建出来。 注意：编译器生成的析构函数是非虚的，除非该类的父类的析构函数是虚函数。 为什么不能在构造函数或是析构函数中调用虚函数？因为在构造函数或是析构函数中，对于虚函数的调用并不会下降到子类的虚函数中。因为在这些过程中，子类的构造尚未完成或者是子类的析构已经开始，在这两种情况下，该对象都会被视为基类对象。 多态 编译时多态:函数重载函数重载实现原理： 名字重整：编译器将每个唯一的方法和参数列表组合编码成一个对于链接器来说唯一的名字（mangling）。这样C++就可以实现对于重载函数的区分。这也就是为什么只有返回值类型不同的函数无法被区分，因为其返回值类型不会被体现在函数对应的符号中。链接器也就无法区分它们。重整规则：一个被重整的类名字是由名字中字符的整数数量，后面跟原始名字组成的。则 Foo::bar(int,long); //被重整为 bar__3Fooil 运行时多态：虚函数 实现方式：动态绑定 当通过一个基类的指针或者引用调用某个虚函数时，会根据该指针或引用真正指向的对象类型来调用对应的函数。动态绑定的实现过程：当通过对象的指针或引用调用虚函数时，先通过虚指针找到虚函数表，再查表找到对应的虚函数的函数地址，在执行函数调用。在这个过程中，由于对象的指针或者引用所真正指向的对象的不同，会导致找到的虚指针的不同，也就实现了运行期多态。在mvsc中，虚指针位于对象的头部位置。 重载和重写的区别重载是在定义多个具有相同函数名而具有不同参数列表的函数，在编译器实现多态。重写是在子类中重写父类的虚函数，二者除了内部实现以外完全相同，通过这样实现运行时多态。 内联函数内联函数就是将函数体直接放置在调用它的位置，这样就减少了函数调用的开销。inline只是对编译器的一个申请，并不一定会执行。inline与 #define的区别二者都是将函数体替换对于函数的调用。但是编写宏要注意很多细节，较为麻烦。而inline则只需要像编写正常函数一样编写，只需要在函数前面加上inline即可。而且内联函数是个真正的函数，内联函数遵守作用域和访问规则。 C++ 11、14新语法智能指针 资源管理类 引用计数：同一块内存的所有智能指针共用一个引用计数。每个智能指针内部包含一个指向一个内存，该内存存放智能指针指向的内存对应的引用计数。 智能指针实现 shared_ptr、unique_ptr和weak_ptr区别shared_ptr:允许多个指针指向同一个对象 make_shared函数：在堆中分配一个对象，返回该对象的shared_ptr。unique_ptr：独占指向的对象。 由于shared_ptr可能会出现循环引用的情况，因此需要利用 weak_ptr来解决这种情况。weak_ptr：是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。由于weak_ptr所指向的对象可能不存在， 因此我们不能直接使用weak_ptr访问对象，必须调用lock()，如果对象存在就返回一个指向该对象的shared_ptr，这样就可以访问该对象。 右值引用和移动语义移动语义：使用移动操作替换复制操作。实际上的移动操作就是指针的浅拷贝。因此只有在对象中拥有指针时，移动操作才会比拷贝操作更快。右值引用： 左值：能够出现在等号左边的值 右值： 右值引用只能绑定在临时对象上，该对象将要被销毁，并且该对象没有其他用户。 move与forwardmove函数强制将实参转换为右值。forward函数则是只在特定的条件下才实施这样的强制型别转换。：仅当实参是使用右值完成初始化时，它才会指向向右值型别的强制类型转换。也就是说forward会保持类型信息。 四种强制类型转换区别 const_cast：将对象的常量性移除。const_cast只能改变对象的底层const。 对于局部常量，即在函数内部定义的常量，它们位于栈中，去除指针的底层const后，可以对该地址的值进行修改。 对于全局常量，即在全局作用域中定义的常量，它们位于全局区中，通过去除指针的底层const后，仍然不能对该地址的值进行修改。```cppconst int a=7;const int* p=&amp;a; //底层const，指向的对象是constint *pc=const_cast&lt;int*&gt; (p); *pc=5; ``` static_cast：可以执行任何具有明确定义的类型转换，除了去除const以外。 reinterpret_cast：执行低级转型，如 将int转换为int*。改变对于内存值的读取方式。 dynamic_cast：执行安全的向下转型，决定某个对象是否归属于继承体系中的某个类型。使用情景：有时我们希望调用子类的成员函数，但是我们只有一个指向父类的指针或引用，这时我们可以通过dynamic_cast将父类类型的指针转型为子类类型的指针。虽然，这个操作我们也可以通过static_cast完成，但是这样做并不保证安全，因为static_cast无法确定转换后的类型是否在该继承体系中。即dynamic_cast在继承体系中的下行类型转换过程中，会进行类型检查，可也保证安全的向下转型。但是，dynamic_cast会耗费大量时间进行类型比较，因此我们要尽量避免使用dynamic_cast。 lambda表达式test 异常throw抛出异常。之后，throw之后的语句将不再被执行，程序的控制权由throw语句转移到对应的catch模块。当控制权发生转移后， 沿着调用链的函数可能会提早退出 一旦程序开始执行异常处理代码，那么沿着调用链创建的对象将被销毁。 之后，开始执行栈展开，逐层向外层检查catch子句。在检查catch子句与抛出的异常对象类型是否匹配时，必须要能够识别该异常对象的类型。因此编译器必须生成类型描述器，对异常类型进行编码。在执行期，将抛出的异常的类型描述器与catch子句的类型描述器进行比较，当匹配时或者是函数调用栈为空时结束。","categories":[{"name":"博客篇","slug":"博客篇","permalink":"http://www.luckyzmj.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.luckyzmj.cn/tags/C/"},{"name":"面经","slug":"面经","permalink":"http://www.luckyzmj.cn/tags/%E9%9D%A2%E7%BB%8F/"}],"author":"LoveZDF"},{"title":"msvc中类对象的大小","slug":"msvc中类对象大小","date":"2021-09-20T14:40:00.136Z","updated":"2021-09-20T16:19:37.186Z","comments":true,"path":"posts/481f7637.html","link":"","permalink":"http://www.luckyzmj.cn/posts/481f7637.html","excerpt":"","text":"msvc中类对象的大小本文主要来介绍一下在msvc编译器中，类对象的内存分配问题。 test1 空类 class A { public: }; 如果一个类是空类，那么编译器会为它分配一个字符量，这样空类的大小就为1。 test2 不含虚函数的类 class A { char a; double x; public: }; 在计算类对象的大小时需要考虑字节对齐。 数据成员的字节对齐：每个非静态数据成员的偏移量应该是其本身类型大小的整数倍。 整体对象的字节对齐：最终该类对象的大小应该是其非静态数据成员的最大类型大小的整数倍。 因此，在考虑字节对齐的情况下，本例中，类A的大小即为（1(char成员1字节)+7(字节对齐)+8(double成员 8字节)=16字节）。对象内存分布如下： class A size(16): 1&gt; +--- 1&gt; 0 | a 1&gt; | &lt;alignment member&gt; (size=7) 1&gt; 8 | x 1&gt; +--- test3 含有虚函数的类 class A { public: char a; public: virtual void print() { cout &lt;&lt; \"A\" &lt;&lt; endl; } }; 由于在本例中，该类A含有虚函数，因此类对象的首部会存在一个指向虚函数表的指针。因此该类对象的大小为 4(虚表指针4字节)+1(char成员1字节)+3(字节对齐)=8字节。 class A size(8): 1&gt; +--- 1&gt; 0 | {vfptr} 1&gt; 4 | a 1&gt; | &lt;alignment member&gt; (size=3) 1&gt; +--- 1&gt;A::$vftable@: 1&gt; | &amp;A_meta 1&gt; | 0 1&gt; 0 | &amp;A::print 1&gt;A::print this adjustor: 0 test4 class A { public: char a; double x; public: virtual void print() { cout &lt;&lt; \"A\" &lt;&lt; endl; } }; 当对象内存在double类型，或者更大类型的数据成员时，虚表指针的大小就会变为8字节，可能是字节对齐的原因，目前没有找到合理的解释。在本例中，该类对象A的大小是 8(虚表指针)+1(char1字节)+7(字节对齐)+8(double8字节)=24字节 class A size(24): 1&gt; +--- 1&gt; 0 | {vfptr} 1&gt; 8 | c 1&gt; | &lt;alignment member&gt; (size=7) 1&gt;16 | x 1&gt; +--- 1&gt;A::$vftable@: 1&gt; | &amp;A_meta 1&gt; | 0 1&gt; 0 | &amp;A::print 1&gt;A::print this adjustor: 0 test5 多重继承 class C { public: double z; double zz; }; class A { public: char c; double x; public: virtual void print() { cout &lt;&lt; \"A\" &lt;&lt; endl; } }; class B :public C,public A { int c; public: void print() { cout &lt;&lt; \"B\" &lt;&lt; endl; } }; 当某个类对象同时继承多个类时(即多重继承)，则父类中有虚函数的类对象位于前面，没有虚函数的类对象位于后面。在本例中，如果类A中没有虚函数，那么类C应该位于类B的前部，但是由于A中包含虚函数，因此类A在前，类C在后。类B大小： 24(类A大小24字节)+16(类C大小16字节)+4(int成员变量4字节)+4(字节对齐4字节)=48字节 1&gt;class B size(48): 1&gt; +--- 1&gt; 0 | +--- (base class A) 1&gt; 0 | | {vfptr} 1&gt; 8 | | c 1&gt; | | &lt;alignment member&gt; (size=7) 1&gt;16 | | x 1&gt; | +--- 1&gt;24 | +--- (base class C) 1&gt;24 | | z 1&gt;32 | | zz 1&gt; | +--- 1&gt;40 | c 1&gt; | &lt;alignment member&gt; (size=4) 1&gt; +--- 1&gt;B::$vftable@: 1&gt; | &amp;B_meta 1&gt; | 0 1&gt; 0 | &amp;B::print 1&gt;B::print this adjustor: 0 test6 单一虚继承对于虚继承，虚基类位于子类的末尾位置，不考虑字节对齐。在子类部分的首部(不包括继承其他类的部分)有一个指向该虚基类的虚指针。该虚指针的对齐方式与前面的虚表指针一样。 class C { public: char s; }; class A { char az; public: }; class B : virtual public A, public C { char ca; int a; double s; public: }; void main() { cout &lt;&lt; sizeof(B) &lt;&lt; endl; } 1&gt;class B size(25): 1&gt; +--- 1&gt; 0 | +--- (base class C) 1&gt; 0 | | s 1&gt; | +--- 1&gt; 4 | {vbptr} 1&gt; 9 | ca 1&gt; | &lt;alignment member&gt; (size=2) 1&gt;12 | a 1&gt;16 | s 1&gt; +--- 1&gt; +--- (virtual base A) 1&gt;24 | az 1&gt; +--- 1&gt;B::$vbtable@: 1&gt; 0 | -4 1&gt; 1 | 20 (Bd(B+4)A) 1&gt;vbi: class offset o.vbptr o.vbte fVtorDisp 1&gt; A 24 4 4 0 对于此对象模型的解释，可以从以下这篇文章得到一个大概的解释。https://blog.csdn.net/chengonghao/article/details/51679743 首先，类C在首部，大小为1个字节，而后就是虚指针，由于虚指针需要保证字节对齐，因此首先要在虚指针前面添加三个字节，保证指针字节对齐，又由于类B需要虚指针整体字节对齐，因此需要在虚指针后面添加一个字节，保证虚指针整体大小为8个字节。因此，类B的大小为(1(类C 1字节)+3(字节对齐3字节)+4(虚指针4字节)+1(字节对齐)+1(char1字节)+2(字节对齐)+4(int4字节)+8(double 4字节))=25字节。 test7 菱形继承（含有虚继承） class A { public: char az; public: }; class B : virtual public A{ char ca; int a; double s; public: }; class C : virtual public A { char ca; int a; double s; public: }; class E :public C,public B { int a; }; void main() { B b; cout &lt;&lt; sizeof(E) &lt;&lt; endl; } 在本例中，类B和类C都虚继承类A，而类E有继承类B和类C。 类E的大小为 24(类C不包含虚基类的部分的大小)+24(类B不包含虚基类的部分的大小)+4(int4字节)+4(字节对齐4字节)+1(虚基类A1字节)=57字节 1&gt;class E size(57): 1&gt; +--- 1&gt; 0 | +--- (base class C) 1&gt; 0 | | {vbptr} 1&gt; 8 | | ca 1&gt; | | &lt;alignment member&gt; (size=3) 1&gt;12 | | a 1&gt;16 | | s 1&gt; | +--- 1&gt;24 | +--- (base class B) 1&gt;24 | | {vbptr} 1&gt;32 | | ca 1&gt; | | &lt;alignment member&gt; (size=3) 1&gt;36 | | a 1&gt;40 | | s 1&gt; | +--- 1&gt;48 | a 1&gt; | &lt;alignment member&gt; (size=4) 1&gt; +--- 1&gt; +--- (virtual base A) 1&gt;56 | az 1&gt; +--- 1&gt;E::$vbtable@C@: 1&gt; 0 | 0 1&gt; 1 | 56 (Ed(C+0)A) 1&gt;E::$vbtable@B@: 1&gt; 0 | 0 1&gt; 1 | 32 (Ed(B+0)A) 1&gt;vbi: class offset o.vbptr o.vbte fVtorDisp 1&gt; A 56 0 4 0 test8 虚继承+虚函数 class A { int t; const double i = 4; public: A(int a) :t(a) {} virtual void print() { cout &lt;&lt; \"A\"; } }; class B:virtual public A { int t1; public: B(int x, int y) :A(x), t1(y) {} void print() { cout &lt;&lt; \"B\"; } virtual void print2() { cout &lt;&lt; \"B2\"; } }; class C { int a; }; void main() { B b(1,2); A* a = &amp;b; a-&gt;print(); } 当对象中同时用于虚函数指针和虚基类指针时，虚函数指针在前面。 1&gt;class B size(40): 1&gt; +--- 1&gt; 0 | {vfptr} 1&gt; 4 | {vbptr} 1&gt; 8 | t1 1&gt; +--- 1&gt;12 | (vtordisp for vbase A) //? 1&gt; +--- (virtual base A) 1&gt;16 | {vfptr} 1&gt;24 | t 1&gt; | &lt;alignment member&gt; (size=4) 1&gt;32 | i 1&gt; +--- 1&gt;B::$vftable@B@: 1&gt; | &amp;B_meta 1&gt; | 0 1&gt; 0 | &amp;B::print2 1&gt;B::$vbtable@: 1&gt; 0 | -4 1&gt; 1 | 12 (Bd(B+4)A) 1&gt;B::$vftable@A@: 1&gt; | -16 1&gt; 0 | &amp;(vtordisp) B::print 1&gt;B::print this adjustor: 16 1&gt;B::print2 this adjustor: 0 1&gt;vbi: class offset o.vbptr o.vbte fVtorDisp 1&gt; A 16 4 4 1","categories":[{"name":"博客篇","slug":"博客篇","permalink":"http://www.luckyzmj.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.luckyzmj.cn/tags/C/"}],"author":"Luckey"},{"title":"C++内存分区","slug":"对于c++ 内存分区的讨论","date":"2021-09-20T10:03:51.528Z","updated":"2021-09-20T14:58:20.658Z","comments":true,"path":"posts/14b8e558.html","link":"","permalink":"http://www.luckyzmj.cn/posts/14b8e558.html","excerpt":"","text":"windows下C++的内存分区五大分区在windows中五大分区地址由高至低依次是： 堆区：由用户主动申请 栈区：由高地址向低地址生长，编译器自动分配。存放局部变量、局部常量 全局区：存放全局变量，全局静态变量、局部静态变量。 常量区：存放文字常量、全局常量、全局静态常量、局部静态常量。 代码区：存放程序代码。 其中常量区和代码区都是只可读不可写。 测试const int a1 = 5; //全局常量 static const int a2 = 11; //全局静态常量 static int a3 = 12; //全局静态变量 int a4 = 6; //全局变量 void main() { const char* s = \"32\"; //文字常量 int a5 = 7; //局部变量 const int a6 = 8;//局部常量 static const int a7 = 9; //局部静态常量 static int a8 = 10; //局部静态变量 int* p1 = const_cast&lt;int*&gt;(&amp;a1); int* p2 = const_cast&lt;int*&gt;(&amp;a2); int* p3 = (&amp;a3); int* p4 = const_cast&lt;int*&gt;(&amp;a4); int* p5 = (&amp;a5); int* p6 = const_cast&lt;int*&gt;(&amp;a6); int* p7 = const_cast&lt;int*&gt;(&amp;a7); int* p8 = (&amp;a8); int* p9 = new int(11); //堆中申请的局部变量 const int* p10 = new int(12); //堆中申请的局部常量 *p2 = 3; } 测试结果 由以上测试结果可得，各中类型数据所在的位置分布 类型 地址 所在分区 堆局部常量 0x011775a8 堆区 堆局部变量 0x01170588 堆区 局部变量 0x00faf6fc 栈区 局部常量 0x00faf6f0 栈区 局部静态变量 0x00eaa008 全局区 静态全局变量 0x00eaa004 全局区 全局变量 0x00eaa000 全局区 文字常量 0x00ea7b40 常量区 局部静态常量 0x00ea7b38 常量区 全局静态常量 0x00ea7b34 常量区 全局常量 0x00ea7b30 常量区 这样我们就得到了不同类型数据的内存分布位置。 并且我们还可以知道 由于a5先于a6定义，而a5的地址高于a6可以知道，栈内存是从高地址向地址生长的。我们可以进一步测试： void main() { int a1=1; int a2 = 1; int a3 = 1; int a4 = 1; cout &lt;&lt; &amp;a1 &lt;&lt; endl; cout &lt;&lt; &amp;a2 &lt;&lt; endl; cout &lt;&lt; &amp;a3&lt;&lt; endl; cout &lt;&lt; &amp;a4 &lt;&lt; endl; } 可以明显知道，变量a1到a4地址逐个降低，进一步说明了栈内存是从高地址向低地址生长。","categories":[{"name":"博客篇","slug":"博客篇","permalink":"http://www.luckyzmj.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.luckyzmj.cn/tags/C/"}],"author":"LoveZDF"},{"title":"型别推导","slug":"c++中的型别推导规则","date":"2021-09-20T10:00:19.195Z","updated":"2021-09-20T10:04:11.233Z","comments":true,"path":"posts/89c1cd20.html","link":"","permalink":"http://www.luckyzmj.cn/posts/89c1cd20.html","excerpt":"","text":"型别推导模板中的型别推导规则template &lt;typename T&gt; void f(Paramtype param); f(expr); 以上是模板和调用的一般形式。现在我们需要考虑在模板型别推导过程中出现的一般情况。 Paramtype 是个指针或者引用，但不是万能引用。在这种情况下，型别推导将会按照如下过程运作： 如果expr具有引用，则将引用忽略。（在形参类型不是万能引用的情况下，实参类型是否具有引用对于形参的类型并无影响） 将忽略引用后的expr与Paramtype 进行模式匹配，推导出T的类型。 Paramtype是个万能引用。 如果expr是个左值，T和Paramtype都会被推导为左值引用。 如果expr是个右值，则应用第一种情况的规则。 Paramtype既不是指针也不是引用。这也就意味着在这种情况下采用传值的方式。由于在传值的情况下，形参都是实参的副本，这样在进行型别推导时就需要忽略实参的引用以及const和volatile。 在模板型别推导过程中，数组或函数型别的实参会退化成对应的指针，除非他们被用来初始化引用。 auto 型别推导auto将等号右边的值看做实参，进行型别推导。其推导规则与模板型别推导基本一致。auto型别推导与模板型别推导的唯一不同就是当采用列表初始化的方式初始化变量时，该变量的类型会被推导为initializer_list&lt; T&gt;。 auto a{1}; //a的类型被推导为initializer_list&lt;int&gt; auto a1{1,1.0}; //由于大括号中的值类型不一致，因此无法推导出initializer_list&lt;T&gt; 中的T decltype 型别推导 在绝大多数情况下，decltype会得出变量或表达式的型别而不做任何修改。 对于型别为T的表达式，除非该表达式仅有一个名字，decltype总是得出型别T&amp;。","categories":[{"name":"博客篇","slug":"博客篇","permalink":"http://www.luckyzmj.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.luckyzmj.cn/tags/C/"}],"author":"Luckey"},{"title":"解析vector在msvc中的增长方式","slug":"解析vector","date":"2021-08-14T16:00:00.000Z","updated":"2021-09-20T10:06:22.613Z","comments":true,"path":"posts/8544f5f8.html","link":"","permalink":"http://www.luckyzmj.cn/posts/8544f5f8.html","excerpt":"","text":"解析vector在msvc中的增长方式 测试首先，我们在vs2019中对于vector的增长方式进行测试。 for (int i = 0; i &lt; 100; ++i) { a.push_back(i); cout &lt;&lt; a.capacity() &lt;&lt; \" \"; } 结果 由图中结果可以看出，每次重新分配空间，vector的容量增长了原容量的一半。 分析源码首先，调用push_back函数。在push_back函数内部调用emplace_back。而在emplace_back内部，当容量不足时，会调用 _Emplace_reallocate函数，来重新分配内存空间。在该函数内部，会更新size与capacity的值。通过函数 _Calculate_growth来计算vector新的容量值。 如果旧容量与旧容量的1/2的和超过了所能分配的最大内存，则返回该最大内存的值。 否则，将新内存更新为旧容量与旧容量的1/2的和。即容量增长了原容量的一半。 如果增长后的容量值仍不足，则将容量更新为_Newsize。即如果一次性在vector中添加了超过原容量的1/2的数据，那么新容量的值就是添加数据所占的容量与原容量的和，即不预留额外空间。 原因从以上测试结果，以及对于源码的分析可以看出，vector每次增长原容量的一半。那么这么做的原因是什么呢？C++ STL 中 vector 内存用尽后, 为什么每次是 2 倍的增长, 而不是 3 倍或其他值? - Milo Yip的回答 - 知乎https://www.zhihu.com/question/36538542/answer/67994276 如果采用2倍增长的策略，由于每次新分配的内存必定大于之前所分配内存的总和，这样之前缓存就永远无法被利用。而如果采用1.5倍增长的话，理论上就可以利用之前分配过的缓存（缓存友好）。","categories":[{"name":"博客篇","slug":"博客篇","permalink":"http://www.luckyzmj.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.luckyzmj.cn/tags/C/"}],"author":"LoveZDF"},{"title":"解析迭代器","slug":"解析迭代器","date":"2020-03-14T16:00:00.000Z","updated":"2021-09-20T10:04:11.235Z","comments":true,"path":"posts/b67a3ab3.html","link":"","permalink":"http://www.luckyzmj.cn/posts/b67a3ab3.html","excerpt":"","text":"迭代器迭代器失效向容器中添加元素： 如果容器是vector或string，并且重新分配内存空间，那么所有迭代器、指针、引用都会失效。如果没有重新分配内存，那么在添加元素位置之后的迭代器、指针、引用都会失效。 如果容器是deque，那么插入到除首尾之外的任何位置都会导致迭代器、指针、引用失效。插入到首尾位置，迭代器会失效。 如果容器是list和forward_list，指向容器的迭代器、指针和引用仍有效。 从容器中删除元素： 如果容器是list和forward_list，指向容器其他位置的迭代器、引用、指针仍然有效。 对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器失效，但其他迭代器、指针和引用不会失效。如果是删除首元素，这些也不会受影响。 对于vector和string，指向被删除元素之前元素的迭代器、引用指针仍有效。 迭代器失效原因迭代器之所以会失效是由于迭代器原本指向的对象的地址发生改变，导致迭代器所存储的地址中的对象将不再正确。 在vector和string中，如果重新分配内存，那么其中所有元素的地址都会发生改变。那么我们在这之前所获得的迭代器指向的对象则发生改变，如果我们仍然继续使用这些迭代器，将会导致严重的错误。如果没有重新分配内存，那么在该位置之后元素需要全部后移，那么指向这些元素的迭代器当然也会失效。 在deque中，由于deque的底层实现方式比较特殊，因此其迭代器可能失效的情况也与vector和string不太一样。如果在deque的首部或者尾部插入元素： 首先，由于deque的特殊设计，deque的内部元素不会发生移动，那么这些元素的指针和引用便不会失效。但是由于在首部或尾部添加元素可能会导致deque增加新的chunk，这就会导致其迭代器失效。 而如果要在deque内部插入元素的话，那么其他元素都可能会发生移动，因此这些元素的迭代器、指针和引用都会失效。 在list中，由于list是环形链表，因此无论是执行插入还是删除操作都不会改变其元素的地址，因此list中的迭代器、指针和引用不会失效。 msvc能够检测迭代器是否失效msvc在debug模式下可以检测迭代器是否失效。检测方法：c++标准库是如何实现迭代器失效的？ - rayhunter的回答 - 知乎https://www.zhihu.com/question/460078504/answer/1893604802通过一个隐式的迭代器链表来检测迭代器是否失效。","categories":[{"name":"博客篇","slug":"博客篇","permalink":"http://www.luckyzmj.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.luckyzmj.cn/tags/C/"}],"author":"LoveZDF"}],"categories":[{"name":"博客篇","slug":"博客篇","permalink":"http://www.luckyzmj.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.luckyzmj.cn/tags/C/"},{"name":"面经","slug":"面经","permalink":"http://www.luckyzmj.cn/tags/%E9%9D%A2%E7%BB%8F/"}]}